import*as e from"fs";import{promises as t,constants as i}from"fs";import{ofError as r,of as n,ofAny as s}from"@await-of/of";import a,{join as o,resolve as c,extname as f,parse as l,basename as u,dirname as d}from"path";import y from"assert";async function createDirectory(e,i="0777",n=!0){const s=await r(t.mkdir(e,{mode:i,recursive:n}));return s||!0}async function getStatus(e){return n(t.stat(e))}async function writeFile(e,i,n){const s=await r(t.writeFile(e,i,n));return s||!0}async function createFile(e,i="0777"){const[n,s]=await getStatus(e);if(!s&&n.isFile())return!0;const o=a.dirname(e);if(s&&"ENOENT"===s.code){const t=await createDirectory(o,i);if(!0!==t)return t;const r=await writeFile(e,"",{mode:i,flag:"w"});return!0===r||r}return n.isDirectory()?await writeFile(e,"",{mode:i,flag:"w"}):await r(t.readdir(o))}async function accessWrapper(e,i){const n=await r(t.access(i,e));return n||!0}async function dirIsExecutable(e){return accessWrapper(i.X_OK,e)}async function dirIsReadable(e){return accessWrapper(i.R_OK,e)}async function dirIsVisible(e){return accessWrapper(i.F_OK,e)}async function dirIsWritable(e){return accessWrapper(i.W_OK,e)}async function fileIsExecutable(e){return accessWrapper(i.X_OK,e)}async function fileIsReadable(e){return accessWrapper(i.R_OK,e)}async function fileIsVisible(e){return accessWrapper(i.F_OK,e)}async function fileIsWritable(e){return accessWrapper(i.W_OK,e)}async function fileTruncate(e,i=0){const n=await r(t.truncate(e,i));return n||!0}async function listContents(e){const[i,r]=await s(t.readdir(e));return r||i}function pathFrom(e,...t){let i;return i=Array.isArray(e)?e.map(e=>e.toString()):[e.toString()],t.length&&(i=i.concat(t.map(e=>e.toString()))),o(...i)}async function listDirectories(e){const t=await listContents(e);if(!Array.isArray(t))return t;return(await Promise.all(t.map(async t=>{const i=pathFrom(e,t),[r,n]=await getStatus(i);if(!n&&r.isDirectory())return t}))).filter(e=>e)}async function listFiles(e){const t=await listContents(e);if(!Array.isArray(t))return t;return(await Promise.all(t.map(async t=>{const i=pathFrom(e,t),[r,n]=await getStatus(i);if(!n&&!r.isDirectory())return t}))).filter(e=>e)}async function move(e,i){const n=await r(t.rename(e,i));return n||!0}function absolutePathFrom(e,...t){let i;return i=Array.isArray(e)?e.map(e=>e.toString()):[e.toString()],t.length&&(i=i.concat(t.map(e=>e.toString()))),c(...i)}function fileExtension(e){return f(e).substring(1)}function fileName(e){return l(e).name}function fileNameExt(e){return u(e)}function filePath(e){return d(e)}async function readFileToBase64(e){const[i,r]=await n(t.readFile(e,"base64"));return r||i.toString()}async function readFileToBuffer(e){const[i,r]=await n(t.readFile(e,"binary"));return r||Buffer.from(i)}async function readFileToString(e){const[i,r]=await n(t.readFile(e,"utf8"));return r||i.toString()}const m="win32"===process.platform;function rimraf(t,i,r){let n=0,s=r,a=i;"function"==typeof a&&(s=a,a={}),y(t,"remove(): missing path"),y.strictEqual(typeof t,"string","remove(): path should be a string"),y.strictEqual(typeof s,"function","remove(): callback function required"),y(a,"remove(): invalid options argument provided"),y.strictEqual(typeof a,"object","remove(): options should be object"),function defaults(t){["unlink","chmod","stat","lstat","rmdir","readdir"].forEach(i=>{t[i]=t[i]||e[i]}),t.maxBusyTries=t.maxBusyTries||3}(a),rimraf_(t,a,(function callbackRimraf(e){if(e){if(("EBUSY"===e.code||"ENOTEMPTY"===e.code||"EPERM"===e.code)&&n<a.maxBusyTries){n++;return void setTimeout(()=>rimraf_(t,a,callbackRimraf),100*n)}if("ENOENT"===e.code)return void s(null)}s(e)}))}function rimraf_(e,t,i){y(e),y(t),y("function"==typeof i),t.lstat(e,(r,n)=>r&&"ENOENT"===r.code?i(null):r&&"EPERM"===r.code&&m?fixWinEPERM(e,t,r,i):n&&n.isDirectory()?rmdir(e,t,r,i):void t.unlink(e,r=>{if(r){if("ENOENT"===r.code)return i(null);if("EPERM"===r.code)return m?fixWinEPERM(e,t,r,i):rmdir(e,t,r,i);if("EISDIR"===r.code)return rmdir(e,t,r,i)}return i(r)}))}function fixWinEPERM(e,t,i,r){return y(e),y(t),y("function"==typeof r),i&&y(i instanceof Error),t.chmod(e,438,n=>{n?"ENOENT"===n.code?r(null):r(i):t.stat(e,(n,s)=>{n?"ENOENT"===n.code?r(null):r(i):s.isDirectory()?rmdir(e,t,i,r):t.unlink(e,r)})}),null}function rmdir(e,t,i,r){return y(e),y(t),i&&y(i instanceof Error),y("function"==typeof r),t.rmdir(e,n=>{!n||"ENOTEMPTY"!==n.code&&"EEXIST"!==n.code&&"EPERM"!==n.code?n&&"ENOTDIR"===n.code?r(i):r(n):function removeSubPath(e,t,i){y(e),y(t),y("function"==typeof i),t.readdir(e,(r,n)=>{if(r)return i(r);let s,o=n.length;if(0===o)return t.rmdir(e,i);n.forEach(r=>{rimraf(a.join(e,r),t,r=>{s||(r?i(s=r):(--o,0===o&&t.rmdir(e,i)))})})})}(e,t,r)}),null}async function remove(e){return new Promise((t,i)=>{rimraf(e,{},e=>{e?i(e):t()})})}function removeNonBlocking(e){remove(e).then(()=>{}).catch(()=>{})}async function isDirExists(e){const[t,i]=await getStatus(e);return!i&&t.isDirectory()}async function isFileExists(e){const[t,i]=await getStatus(e);return!i&&t.isFile()}async function isPathExists(e){const[t]=await getStatus(e);return Boolean(t)}async function writeJSON(e,t,i){let r;try{r=JSON.stringify(t)}catch(e){return e}return writeFile(e,r,i)}function _defineProperty(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}class HileSystemLocal{constructor(){_defineProperty(this,"absolutePathFrom",absolutePathFrom),_defineProperty(this,"createDirectory",createDirectory),_defineProperty(this,"createFile",createFile),_defineProperty(this,"dirIsExecutable",dirIsExecutable),_defineProperty(this,"dirIsReadable",dirIsReadable),_defineProperty(this,"dirIsVisible",dirIsVisible),_defineProperty(this,"dirIsWritable",dirIsWritable),_defineProperty(this,"getStatus",getStatus),_defineProperty(this,"isDirExists",isDirExists),_defineProperty(this,"isFileExists",isFileExists),_defineProperty(this,"isPathExists",isPathExists),_defineProperty(this,"fileExtension",fileExtension),_defineProperty(this,"fileName",fileName),_defineProperty(this,"fileNameExt",fileNameExt),_defineProperty(this,"filePath",filePath),_defineProperty(this,"fileIsExecutable",fileIsExecutable),_defineProperty(this,"fileIsReadable",fileIsReadable),_defineProperty(this,"fileIsVisible",fileIsVisible),_defineProperty(this,"fileIsWritable",fileIsWritable),_defineProperty(this,"fileTruncate",fileTruncate),_defineProperty(this,"listContents",listContents),_defineProperty(this,"listDirectories",listDirectories),_defineProperty(this,"listFiles",listFiles),_defineProperty(this,"move",move),_defineProperty(this,"pathFrom",pathFrom),_defineProperty(this,"readFileToBase64",readFileToBase64),_defineProperty(this,"readFileToBuffer",readFileToBuffer),_defineProperty(this,"readFileToString",readFileToString),_defineProperty(this,"remove",remove),_defineProperty(this,"removeNonBlocking",removeNonBlocking),_defineProperty(this,"writeFile",writeFile),_defineProperty(this,"writeJSON",writeJSON)}}export{HileSystemLocal,absolutePathFrom,createDirectory,createFile,dirIsExecutable,dirIsReadable,dirIsVisible,dirIsWritable,fileExtension,fileIsExecutable,fileIsReadable,fileIsVisible,fileIsWritable,fileName,fileNameExt,filePath,fileTruncate,getStatus,isDirExists,isFileExists,isPathExists,listContents,listDirectories,listFiles,move,pathFrom,readFileToBase64,readFileToBuffer,readFileToString,remove,removeNonBlocking,writeFile,writeJSON};
//# sourceMappingURL=index.mjs.map
