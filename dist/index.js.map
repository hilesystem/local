{"version":3,"file":"index.js","sources":["../src/core/create/createDirectory.mjs","../src/core/status/getStatus.mjs","../src/core/write/writeFile.mjs","../src/core/create/createFile.mjs","../src/core/access/wrapper.mjs","../src/core/dir/dirIsExecutable.mjs","../src/core/dir/dirIsReadable.mjs","../src/core/dir/dirIsVisible.mjs","../src/core/dir/dirIsWritable.mjs","../src/core/file/fileIsExecutable.mjs","../src/core/file/fileIsReadable.mjs","../src/core/file/fileIsVisible.mjs","../src/core/file/fileIsWritable.mjs","../src/core/file/fileTruncate.mjs","../src/core/path/absolutePathFrom.mjs","../src/core/path/fileExtension.mjs","../src/core/path/fileName.mjs","../src/core/path/fileNameExt.mjs","../src/core/path/filePath.mjs","../src/core/path/pathFrom.mjs","../src/core/remove/remove.mjs","../src/core/status/isDirExists.mjs","../src/core/status/isFileExists.mjs","../src/core/status/isPathExists.mjs","../src/core/HileSystemLocal.mjs"],"sourcesContent":["import { promises } from \"fs\";\n\nimport { ofError } from \"@r37r0m0d3l/of\";\n\n/**\n * @name createDirectory\n * @description Asynchronous create a directory.\n * @since 0.0.10\n * @async\n * @param {string|Buffer|URL} dirPath\n * @param {number|string=} mode\n * @param {boolean=} recursive\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function createDirectory(dirPath, mode = \"0777\", recursive = true) {\n  const dirError = await ofError(promises.mkdir(dirPath, { mode, recursive }));\n  if (dirError) {\n    return dirError;\n  }\n  return true;\n}\n","import { promises } from \"fs\";\n\nimport { of } from \"@r37r0m0d3l/of\";\n\n/**\n * @name getStatus\n * @description Get file status.\n * @since 0.0.11\n * @async\n * @param {string|Buffer|URL} path\n * @returns {Promise<[fs.Stats|undefined],[Error|{name: string, message: string, stack?: string}]>}\n */\nexport async function getStatus(path) {\n  return of(promises.stat(path));\n}\n","import { promises } from \"fs\";\n\nimport { ofError } from \"@r37r0m0d3l/of\";\n\n/**\n * @name writeFile\n * @description Asynchronously writes data to a file, replacing the file if it already exists.\n * @since 0.0.10\n * @async\n * @param {string|Buffer|URL|FileHandle} filePath\n * @param {*=} data\n * @param {*|null|string=} options\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function writeFile(filePath, data, options) {\n  const writeError = await ofError(promises.writeFile(filePath, data, options));\n  if (writeError) {\n    return writeError;\n  }\n  return true;\n}\n","import path from \"path\";\nimport { promises } from \"fs\";\n\nimport { ofError } from \"@r37r0m0d3l/of\";\n\nimport { createDirectory } from \"./createDirectory.mjs\";\nimport { getStatus } from \"../status/getStatus.mjs\";\nimport { writeFile } from \"../write/writeFile.mjs\";\n\n/**\n * @name createFile\n * @description Asynchronous create a file.\n * @since 0.0.11\n * @async\n * @param {string|Buffer|URL} pathLike\n * @param {number|string=} mode\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function createFile(pathLike, mode = \"0777\") {\n  const [status, error] = await getStatus(pathLike);\n  if (!error && status.isFile()) {\n    return true;\n  }\n  const dirPath = path.dirname(pathLike);\n  if (error) {\n    if (error.code === \"ENOENT\") {\n      const dirCreated = await createDirectory(dirPath, mode);\n      if (dirCreated !== true) {\n        return dirCreated;\n      }\n      const fileWritten = await writeFile(pathLike, \"\", { mode, flag: \"w\" });\n      if (fileWritten !== true) {\n        return fileWritten;\n      }\n      return true;\n    }\n  }\n  if (status.isDirectory()) {\n    return await writeFile(pathLike, \"\", { mode, flag: \"w\" });\n  } else {\n    return await ofError(promises.readdir(dirPath));\n  }\n}\n","import { promises } from \"fs\";\n\nimport { ofError } from \"@r37r0m0d3l/of\";\n\n/**\n * @name accessWrapper\n * @description Asynchronously tests a user's permissions for the file specified by path.\n * @since 0.0.1\n * @async\n * @param {number} mode\n * @param {string|Buffer|URL} path\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function accessWrapper(mode, path) {\n  const fsError = await ofError(promises.access(path, mode));\n  if (!fsError) {\n    return true;\n  }\n  return fsError;\n}\n","import { constants } from \"fs\";\n\nimport { accessWrapper } from \"../access/wrapper.mjs\";\n\n/**\n * @name dirIsExecutable\n * @description Directory can be executed by the calling process\n * @since 0.0.5\n * @async\n * @param {string|Buffer|URL} pathToDir\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function dirIsExecutable(pathToDir) {\n  return accessWrapper(constants.X_OK, pathToDir);\n}\n","import { constants } from \"fs\";\n\nimport { accessWrapper } from \"../access/wrapper.mjs\";\n\n/**\n * @name dirIsReadable\n * @description Directory is visible to the calling process\n * @since 0.0.1\n * @async\n * @param {string|Buffer|URL} pathToDir\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function dirIsReadable(pathToDir) {\n  return accessWrapper(constants.R_OK, pathToDir);\n}\n","import { constants } from \"fs\";\n\nimport { accessWrapper } from \"../access/wrapper.mjs\";\n\n/**\n * @name dirIsVisible\n * @description Directory is visible to the calling process\n * @since 0.0.5\n * @async\n * @param {string|Buffer|URL} pathToDir\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function dirIsVisible(pathToDir) {\n  return accessWrapper(constants.F_OK, pathToDir);\n}\n","import { constants } from \"fs\";\n\nimport { accessWrapper } from \"../access/wrapper.mjs\";\n\n/**\n * @name dirIsWritable\n * @description Directory can be written by the calling process\n * @since 0.0.1\n * @async\n * @param {string|Buffer|URL} pathToDir\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function dirIsWritable(pathToDir) {\n  return accessWrapper(constants.W_OK, pathToDir);\n}\n","import { constants } from \"fs\";\n\nimport { accessWrapper } from \"../access/wrapper.mjs\";\n\n/**\n * @name fileIsExecutable\n * @description File can be executed by the calling process\n * @since 0.0.5\n * @async\n * @param {string|Buffer|URL} pathToFile\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function fileIsExecutable(pathToFile) {\n  return accessWrapper(constants.X_OK, pathToFile);\n}\n","import { constants } from \"fs\";\n\nimport { accessWrapper } from \"../access/wrapper.mjs\";\n\n/**\n * @name fileIsReadable\n * @description File is visible to the calling process\n * @since 0.0.1\n * @async\n * @param {string|Buffer|URL} pathToFile\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function fileIsReadable(pathToFile) {\n  return accessWrapper(constants.R_OK, pathToFile);\n}\n","import { constants } from \"fs\";\n\nimport { accessWrapper } from \"../access/wrapper.mjs\";\n\n/**\n * @name fileIsVisible\n * @description File is visible to the calling process\n * @since 0.0.5\n * @async\n * @param {string|Buffer|URL} pathToFile\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function fileIsVisible(pathToFile) {\n  return accessWrapper(constants.F_OK, pathToFile);\n}\n","import { constants } from \"fs\";\n\nimport { accessWrapper } from \"../access/wrapper.mjs\";\n\n/**\n * @name fileIsWritable\n * @description File can be written by the calling process\n * @since 0.0.1\n * @async\n * @param {string|Buffer|URL} pathToFile\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function fileIsWritable(pathToFile) {\n  return accessWrapper(constants.W_OK, pathToFile);\n}\n","import { promises } from \"fs\";\n\nimport { ofError } from \"@r37r0m0d3l/of\";\n\n/**\n * @name fileTruncate\n * @description Truncate a file to a specified length\n * @since 0.0.6\n * @async\n * @param {string|Buffer|URL} pathToFile\n * @param {number=} length\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function fileTruncate(pathToFile, length = 0) {\n  const fsError = await ofError(promises.truncate(pathToFile, length));\n  if (!fsError) {\n    return true;\n  }\n  return fsError;\n}\n","import { resolve } from \"path\";\n\n/**\n * @name pathFrom\n * @description Join all arguments together and normalize the resulting path.\n * Creates absolute path from right to left until an absolute path is constructed.\n * @since 0.1.5\n * @param {string|Array.<string>} paths\n * @param {...string} morePaths\n * @returns {string}\n */\nexport function absolutePathFrom(paths, ...morePaths) {\n  let routes;\n  if (Array.isArray(paths)) {\n    routes = paths.map((path) => path.toString());\n  } else {\n    routes = [paths.toString()];\n  }\n  if (morePaths.length) {\n    routes = routes.concat(morePaths.map((path) => path.toString()));\n  }\n  return resolve(...routes);\n}\n","import { extname } from \"path\";\n\n/**\n * @name fileExtension\n * @description Get file extension.\n * @since 0.1.1\n * @param {string} path\n * @returns {string}\n */\nexport function fileExtension(path) {\n  return extname(path).substring(1);\n}\n","import { parse } from \"path\";\n\n/**\n * @name fileName\n * @description Return the file name without extension.\n * @since 0.1.1\n * @param {string} path\n * @returns {string}\n */\nexport function fileName(path) {\n  return parse(path).name;\n}\n","import { basename } from \"path\";\n\n/**\n * @name fileNameExt\n * @description Return the last portion of a path.\n * @since 0.1.1\n * @param {string} path\n * @returns {string}\n */\nexport function fileNameExt(path) {\n  return basename(path);\n}\n","import { dirname } from \"path\";\n\n/**\n * @name filePath\n * @description Return the directory name of a path.\n * @since 0.1.1\n * @param {string} path\n * @returns {string}\n */\nexport function filePath(path) {\n  return dirname(path);\n}\n","import { join } from \"path\";\n\n/**\n * @name pathFrom\n * @description Join all arguments together and normalize the resulting path.\n * @since 0.1.3\n * @param {string|Array.<string>} paths\n * @param {...string} morePaths\n * @returns {string}\n */\nexport function pathFrom(paths, ...morePaths) {\n  let routes;\n  if (Array.isArray(paths)) {\n    routes = paths.map((path) => path.toString());\n  } else {\n    routes = [paths.toString()];\n  }\n  if (morePaths.length) {\n    routes = routes.concat(morePaths.map((path) => path.toString()));\n  }\n  return join(...routes);\n}\n","import * as fs from \"fs\";\nimport assert from \"assert\";\nimport path from \"path\";\n\nconst IS_WINDOWS = process.platform === \"win32\";\n\nfunction defaults(options) {\n  const methods = [\"unlink\", \"chmod\", \"stat\", \"lstat\", \"rmdir\", \"readdir\"];\n  methods.forEach((method) => {\n    options[method] = options[method] || fs[method];\n  });\n  options.maxBusyTries = options.maxBusyTries || 3;\n}\n\nfunction rimraf(pathLike, options, callback) {\n  let busyTries = 0;\n  if (typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n  assert(pathLike, \"remove(): missing path\");\n  assert.strictEqual(typeof pathLike, \"string\", \"remove(): path should be a string\");\n  assert.strictEqual(typeof callback, \"function\", \"remove(): callback function required\");\n  assert(options, \"remove(): invalid options argument provided\");\n  assert.strictEqual(typeof options, \"object\", \"remove(): options should be object\");\n  defaults(options);\n  rimraf_(pathLike, options, function callbackRimraf(error) {\n    if (error) {\n      if (\n        (error.code === \"EBUSY\" || error.code === \"ENOTEMPTY\" || error.code === \"EPERM\") &&\n        busyTries < options.maxBusyTries\n      ) {\n        busyTries++;\n        const time = busyTries * 100;\n        return setTimeout(() => rimraf_(pathLike, options, callbackRimraf), time);\n      }\n      if (error.code === \"ENOENT\") {\n        error = null;\n      }\n    }\n    callback(error);\n  });\n}\n\nfunction rimraf_(pathLike, options, callback) {\n  assert(pathLike);\n  assert(options);\n  assert(typeof callback === \"function\");\n  options.lstat(pathLike, (error, stats) => {\n    if (error && error.code === \"ENOENT\") {\n      return callback(null);\n    }\n    if (error && error.code === \"EPERM\" && IS_WINDOWS) {\n      return fixWinEPERM(pathLike, options, error, callback);\n    }\n    if (stats && stats.isDirectory()) {\n      return rmdir(pathLike, options, error, callback);\n    }\n    options.unlink(pathLike, (error) => {\n      if (error) {\n        if (error.code === \"ENOENT\") {\n          return callback(null);\n        }\n        if (error.code === \"EPERM\") {\n          if (IS_WINDOWS) {\n            return fixWinEPERM(pathLike, options, error, callback);\n          } else {\n            return rmdir(pathLike, options, error, callback);\n          }\n        }\n        if (error.code === \"EISDIR\") {\n          return rmdir(pathLike, options, error, callback);\n        }\n      }\n      return callback(error);\n    });\n  });\n}\n\nfunction fixWinEPERM(pathLike, options, error, callback) {\n  assert(pathLike);\n  assert(options);\n  assert(typeof callback === \"function\");\n  if (error) {\n    assert(error instanceof Error);\n  }\n  options.chmod(pathLike, 0o666, (errorChMod) => {\n    if (errorChMod) {\n      callback(errorChMod.code === \"ENOENT\" ? null : error);\n    } else {\n      options.stat(pathLike, (errorStat, stats) => {\n        if (errorStat) {\n          callback(errorStat.code === \"ENOENT\" ? null : error);\n        } else if (stats.isDirectory()) {\n          rmdir(pathLike, options, error, callback);\n        } else {\n          options.unlink(pathLike, callback);\n        }\n      });\n    }\n  });\n}\n\nfunction rmdir(pathLike, options, originalError, callback) {\n  assert(pathLike);\n  assert(options);\n  if (originalError) {\n    assert(originalError instanceof Error);\n  }\n  assert(typeof callback === \"function\");\n  options.rmdir(pathLike, (error) => {\n    if (error && (error.code === \"ENOTEMPTY\" || error.code === \"EEXIST\" || error.code === \"EPERM\")) {\n      removeSubPath(pathLike, options, callback);\n    } else if (error && error.code === \"ENOTDIR\") {\n      callback(originalError);\n    } else {\n      callback(error);\n    }\n  });\n}\n\nfunction removeSubPath(pathLike, options, callback) {\n  assert(pathLike);\n  assert(options);\n  assert(typeof callback === \"function\");\n  options.readdir(pathLike, (error, files) => {\n    if (error) {\n      return callback(error);\n    }\n    let count = files.length;\n    let errState;\n    if (count === 0) {\n      return options.rmdir(pathLike, callback);\n    }\n    files.forEach((filePath) => {\n      rimraf(path.join(pathLike, filePath), options, (error) => {\n        if (errState) {\n          return;\n        }\n        if (error) {\n          return callback((errState = error));\n        }\n        if (--count === 0) {\n          options.rmdir(pathLike, callback);\n        }\n      });\n    });\n  });\n}\n\n/**\n * @name remove\n * @description Removes a file or directory.\n * @since 0.1.1\n * @async\n * @param {string} pathLike\n * @returns {Promise<undefined|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function remove(pathLike) {\n  return new Promise((resolve, reject) => {\n    rimraf(pathLike, {}, (error) => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n","import { getStatus } from \"./getStatus.mjs\";\n\n/**\n * @name isDirExists\n * @description Get directory status.\n * @since 0.0.11\n * @async\n * @param {string|Buffer|URL} path\n * @returns {Promise<boolean>}\n */\nexport async function isDirExists(path) {\n  const [status, error] = await getStatus(path);\n  if (error) {\n    return false;\n  }\n  return status.isDirectory();\n}\n","import { getStatus } from \"./getStatus.mjs\";\n\n/**\n * @name isFileExists\n * @description Get file status.\n * @since 0.0.11\n * @async\n * @param {string|Buffer|URL} path\n * @returns {Promise<boolean>}\n */\nexport async function isFileExists(path) {\n  const [status, error] = await getStatus(path);\n  if (error) {\n    return false;\n  }\n  return status.isFile();\n}\n","import { getStatus } from \"./getStatus.mjs\";\n\n/**\n * @name isPathExists\n * @description Get path status.\n * @since 0.0.11\n * @async\n * @param {string|Buffer|URL} path\n * @returns {Promise<boolean>}\n */\nexport async function isPathExists(path) {\n  const [status] = await getStatus(path);\n  return Boolean(status);\n}\n","import { absolutePathFrom } from \"./path/absolutePathFrom.mjs\";\nimport { createDirectory } from \"./create/createDirectory.mjs\";\nimport { createFile } from \"./create/createFile.mjs\";\nimport { dirIsExecutable } from \"./dir/dirIsExecutable.mjs\";\nimport { dirIsReadable } from \"./dir/dirIsReadable.mjs\";\nimport { dirIsVisible } from \"./dir/dirIsVisible.mjs\";\nimport { dirIsWritable } from \"./dir/dirIsWritable.mjs\";\nimport { fileExtension } from \"./path/fileExtension.mjs\";\nimport { fileIsExecutable } from \"./file/fileIsExecutable.mjs\";\nimport { fileIsReadable } from \"./file/fileIsReadable.mjs\";\nimport { fileIsVisible } from \"./file/fileIsVisible.mjs\";\nimport { fileIsWritable } from \"./file/fileIsWritable.mjs\";\nimport { fileName } from \"./path/fileName.mjs\";\nimport { fileNameExt } from \"./path/fileNameExt.mjs\";\nimport { filePath } from \"./path/filePath.mjs\";\nimport { fileTruncate } from \"./file/fileTruncate.mjs\";\nimport { getStatus } from \"./status/getStatus.mjs\";\nimport { isDirExists } from \"./status/isDirExists.mjs\";\nimport { isFileExists } from \"./status/isFileExists.mjs\";\nimport { isPathExists } from \"./status/isPathExists.mjs\";\nimport { pathFrom } from \"./path/pathFrom.mjs\";\nimport { remove } from \"./remove/remove.mjs\";\nimport { writeFile } from \"./write/writeFile.mjs\";\n\nexport class HileSystemLocal {\n  /**\n   * @name absolutePathFrom\n   * @description Join all arguments together and normalize the resulting path.\n   * reates absolute path from right to left until an absolute path is constructed.\n   * @since 0.1.5\n   * @public\n   * @param {string|Array.<string>} paths\n   * @param {...string} morePaths\n   * @returns {string}\n   */\n  absolutePathFrom = absolutePathFrom;\n  /**\n   * @name createDirectory\n   * @description Asynchronous create a directory.\n   * @since 0.0.10\n   * @async\n   * @public\n   * @param {string|Buffer|URL} dirPath\n   * @param {number|string=} mode\n   * @param {boolean=} recursive\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  createDirectory = createDirectory;\n  /**\n   * @name createFile\n   * @description Asynchronous create a file.\n   * @since 0.0.11\n   * @async\n   * @public\n   * @param {string|Buffer|URL} pathLike\n   * @param {number|string=} mode\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  createFile = createFile;\n  /**\n   * @name dirIsExecutable\n   * @description Directory can be executed by the calling process\n   * @since 0.0.5\n   * @async\n   * @public\n   * @param {string} pathToDir\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  dirIsExecutable = dirIsExecutable;\n  /**\n   * @name dirIsReadable\n   * @description Directory is visible to the calling process\n   * @since 0.0.1\n   * @async\n   * @public\n   * @param {string} pathToDir\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  dirIsReadable = dirIsReadable;\n  /**\n   * @name dirIsVisible\n   * @description Directory is visible to the calling process\n   * @since 0.0.5\n   * @async\n   * @public\n   * @param {string} pathToDir\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  dirIsVisible = dirIsVisible;\n  /**\n   * @name dirIsWritable\n   * @description Directory can be written by the calling process\n   * @since 0.0.1\n   * @async\n   * @public\n   * @param {string} pathToDir\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  dirIsWritable = dirIsWritable;\n  /**\n   * @name getStatus\n   * @description Get file status.\n   * @since 0.0.11\n   * @async\n   * @public\n   * @param {string|Buffer|URL} path\n   * @returns {Promise<[fs.Stats|undefined],[Error|{name: string, message: string, stack?: string}]>}\n   */\n  getStatus = getStatus;\n  /**\n   * @name isDirExists\n   * @description Get directory status.\n   * @since 0.0.11\n   * @async\n   * @public\n   * @param {string|Buffer|URL} path\n   * @returns {Promise<boolean>}\n   */\n  isDirExists = isDirExists;\n  /**\n   * @name isFileExists\n   * @description Get file status.\n   * @since 0.0.11\n   * @async\n   * @public\n   * @param {string|Buffer|URL} path\n   * @returns {Promise<boolean>}\n   */\n  isFileExists = isFileExists;\n  /**\n   * @name isPathExists\n   * @description Get path status.\n   * @since 0.0.11\n   * @async\n   * @public\n   * @param {string|Buffer|URL} path\n   * @returns {Promise<boolean>}\n   */\n  isPathExists = isPathExists;\n  /**\n   * @name fileExtension\n   * @description Get file extension.\n   * @since 0.1.1\n   * @public\n   * @param {string} path\n   * @returns {string}\n   */\n  fileExtension = fileExtension;\n  /**\n   * @name fileName\n   * @description Return the file name without extension.\n   * @since 0.1.1\n   * @public\n   * @param {string} path\n   * @returns {string}\n   */\n  fileName = fileName;\n  /**\n   * @name fileNameExt\n   * @description Return the last portion of a path.\n   * @since 0.1.1\n   * @public\n   * @param {string} path\n   * @returns {string}\n   */\n  fileNameExt = fileNameExt;\n  /**\n   * @name filePath\n   * @description Return the directory name of a path.\n   * @since 0.1.1\n   * @public\n   * @param {string} path\n   * @returns {string}\n   */\n  filePath = filePath;\n  /**\n   * @name fileIsExecutable\n   * @description File can be executed by the calling process\n   * @since 0.0.5\n   * @async\n   * @public\n   * @param {string|Buffer|URL} pathToFile\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  fileIsExecutable = fileIsExecutable;\n  /**\n   * @name fileIsReadable\n   * @description File is visible to the calling process\n   * @since 0.0.1\n   * @async\n   * @public\n   * @param {string|Buffer|URL} pathToFile\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  fileIsReadable = fileIsReadable;\n  /**\n   * @name fileIsVisible\n   * @description File is visible to the calling process\n   * @since 0.0.5\n   * @async\n   * @public\n   * @param {string|Buffer|URL} pathToFile\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  fileIsVisible = fileIsVisible;\n  /**\n   * @name fileIsWritable\n   * @description File can be written by the calling process\n   * @since 0.0.1\n   * @async\n   * @public\n   * @param {string|Buffer|URL} pathToFile\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  fileIsWritable = fileIsWritable;\n  /**\n   * @name fileTruncate\n   * @description Truncate a file to a specified length\n   * @since 0.0.6\n   * @async\n   * @public\n   * @param {string|Buffer|URL} pathToFile\n   * @param {number=} length\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  fileTruncate = fileTruncate;\n  /**\n   * @name pathFrom\n   * @description Join all arguments together and normalize the resulting path.\n   * @since 0.1.3\n   * @public\n   * @param {string|Array.<string>} paths\n   * @param {...string} morePaths\n   * @returns {string}\n   */\n  pathFrom = pathFrom;\n  /**\n   * @name remove\n   * @description Removes a file or directory.\n   * @since 0.1.1\n   * @async\n   * @public\n   * @param {string} pathLike\n   * @returns {Promise<undefined|Error|{name: string, message: string, stack?: string}>}\n   */\n  remove = remove;\n  /**\n   * @name writeFile\n   * @description Asynchronously writes data to a file, replacing the file if it already exists.\n   * @since 0.0.10\n   * @async\n   * @public\n   * @param {string|Buffer|URL|FileHandle} filePath\n   * @param {*=} data\n   * @param {*|null|string=} options\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  writeFile = writeFile;\n}\n"],"names":["async","createDirectory","dirPath","mode","recursive","dirError","ofError","promises","mkdir","getStatus","path","of","stat","writeFile","filePath","data","options","writeError","createFile","pathLike","status","error","isFile","dirname","code","dirCreated","fileWritten","flag","isDirectory","readdir","accessWrapper","fsError","access","dirIsExecutable","pathToDir","constants","X_OK","dirIsReadable","R_OK","dirIsVisible","F_OK","dirIsWritable","W_OK","fileIsExecutable","pathToFile","fileIsReadable","fileIsVisible","fileIsWritable","fileTruncate","length","truncate","absolutePathFrom","paths","morePaths","routes","Array","isArray","map","toString","concat","resolve","fileExtension","extname","substring","fileName","parse","name","fileNameExt","basename","pathFrom","join","IS_WINDOWS","process","platform","rimraf","callback","busyTries","assert","strictEqual","defaults","forEach","method","fs","maxBusyTries","rimraf_","callbackRimraf","setTimeout","lstat","stats","fixWinEPERM","rmdir","unlink","Error","chmod","errorChMod","errorStat","originalError","removeSubPath","files","errState","count","remove","Promise","reject","isDirExists","isFileExists","isPathExists","Boolean","HileSystemLocal"],"mappings":"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"}