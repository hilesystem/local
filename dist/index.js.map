{"version":3,"file":"index.js","sources":["../src/core/create/createDirectory.js","../src/core/status/getStatus.js","../src/core/write/writeFile.js","../src/core/create/createFile.js","../src/core/list/contents.js","../src/core/dir/dirIsEmpty.js","../src/core/access/wrapper.js","../src/core/dir/dirIsExecutable.js","../src/core/dir/dirIsReadable.js","../src/core/dir/dirIsVisible.js","../src/core/dir/dirIsWritable.js","../src/core/file/fileIsExecutable.js","../src/core/file/fileIsReadable.js","../src/core/file/fileIsVisible.js","../src/core/file/fileIsWritable.js","../src/core/file/fileTruncate.js","../src/core/path/pathFrom.js","../src/core/list/directories.js","../src/core/list/files.js","../src/core/move/move.js","../src/core/path/absolutePathFrom.js","../src/core/path/fileExtension.js","../src/core/path/fileName.js","../src/core/path/fileNameExt.js","../src/core/path/filePath.js","../src/core/read/readFileToBase64.js","../src/core/read/readFileToBuffer.js","../src/core/read/readFileToString.js","../src/core/remove/remove.js","../src/core/remove/removeNonBlocking.js","../src/core/status/isDirExists.js","../src/core/status/isFileExists.js","../src/core/status/isPathExists.js","../src/core/write/writeJSON.js","../src/core/HileSystemLocal.js"],"sourcesContent":["import { promises } from \"fs\";\n\nimport { ofError } from \"@await-of/of\";\n\n/**\n * @name createDirectory\n * @description Asynchronous create a directory.\n * @since 0.0.10\n * @async\n * @param {string|Buffer|URL} dirPath\n * @param {number|string=} mode\n * @param {boolean=} recursive\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function createDirectory(dirPath, mode = \"0777\", recursive = true) {\n  const dirError = await ofError(promises.mkdir(dirPath, { mode, recursive }));\n  if (dirError) {\n    return dirError;\n  }\n  return true;\n}\n","import { promises } from \"fs\";\n\nimport { of } from \"@await-of/of\";\n\n/**\n * @name getStatus\n * @description Get file status.\n * @since 0.0.11\n * @async\n * @param {string|Buffer|URL} path\n * @returns {Promise<Array.<(object|undefined|Error|{name: string, message: string, stack?: string})>>}\n */\nexport async function getStatus(path) {\n  return of(promises.stat(path));\n}\n","import { promises } from \"fs\";\n\nimport { ofError } from \"@await-of/of\";\n\n/**\n * @name writeFile\n * @description Asynchronously writes data to a file, replacing the file if it already exists.\n * @since 0.0.10\n * @async\n * @param {string|Buffer|URL} filePath\n * @param {string} data\n * @param {*|null|string=} options\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n * @example\n * const controller = new AbortController();\n * const { signal } = controller;\n * const data = new Uint8Array(Buffer.from('Hello Node.js'));\n * (async () => {\n *  try {\n *     await writeFile('message.txt', data, { signal });\n *   } catch (error) {\n *     // When a request is aborted - error is an AbortError\n *   }\n * })();\n * // When the request should be aborted\n * controller.abort();\n */\nexport async function writeFile(filePath, data, options) {\n  const writeError = await ofError(promises.writeFile(filePath, data, options));\n  if (writeError) {\n    return writeError;\n  }\n  return true;\n}\n","import path from \"path\";\nimport { promises } from \"fs\";\n\nimport { ofError } from \"@await-of/of\";\n\nimport { createDirectory } from \"./createDirectory.js\";\nimport { getStatus } from \"../status/getStatus.js\";\nimport { writeFile } from \"../write/writeFile.js\";\n\n/**\n * @name createFile\n * @description Asynchronous create a file.\n * @since 0.0.11\n * @async\n * @param {string|Buffer|URL} pathLike\n * @param {number|string=} mode\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function createFile(pathLike, mode = \"0777\") {\n  const [status, error] = await getStatus(pathLike);\n  if (!error && status.isFile()) {\n    return true;\n  }\n  const dirPath = path.dirname(pathLike);\n  if (error) {\n    if (error.code === \"ENOENT\") {\n      const dirCreated = await createDirectory(dirPath, mode);\n      if (dirCreated !== true) {\n        return dirCreated;\n      }\n      const fileWritten = await writeFile(pathLike, \"\", { mode, flag: \"w\" });\n      if (fileWritten !== true) {\n        return fileWritten;\n      }\n      return true;\n    }\n  }\n  if (status.isDirectory()) {\n    return await writeFile(pathLike, \"\", { mode, flag: \"w\" });\n  } else {\n    return await ofError(promises.readdir(dirPath));\n  }\n}\n","import { promises } from \"fs\";\n\nimport { ofAny } from \"@await-of/of\";\n\n/**\n * @name listContents\n * @description Lists files and directories in path\n * @since 0.1.32\n * @async\n * @param {string|Buffer|URL} pathToDir\n * @returns {Promise<Array.<string>|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function listContents(pathToDir) {\n  const [contents, fsError] = await ofAny(promises.readdir(pathToDir));\n  if (fsError) {\n    return fsError;\n  }\n  return contents;\n}\n","import { listContents } from \"../list/contents.js\";\n\nconst EXCLUDE = [\n  // macOS\n  \".AppleDB\",\n  \".AppleDesktop\",\n  \".AppleDouble\",\n  \".DS_Store\",\n  \".DocumentRevisions-V100\",\n  \".LSOverride\",\n  \".Spotlight-V100\",\n  \".TemporaryItems\",\n  \".Trashes\",\n  \".VolumeIcon.icns\",\n  // \"._*\",\n  \".apdisk\",\n  \".com.apple.timemachine.donotpresent\",\n  \".fseventsd\",\n  \"Network Trash Folder\",\n  \"Temporary Items\",\n  // Windows\n  \"$RECYCLE.BIN/\",\n  // \"*.cab\",\n  // \"*.lnk\",\n  // \"*.msi\",\n  // \"*.msix\",\n  // \"*.msm\",\n  // \"*.msp\",\n  // \"*.stackdump\",\n  \"Desktop.ini\",\n  \"Thumbs.db\",\n  \"Thumbs.db:encryptable\",\n  \"desktop.ini\",\n  \"ehthumbs.db\",\n  \"ehthumbs_vista.db\",\n  // Linux\n  // \"*~\",\n  // \".Trash-*\",\n  \".directory\",\n  // \".fuse_hidden*\",\n  // \".nfs*\",\n];\n\n/**\n * @name dirIsEmpty\n * @description Check if a directory is empty\n * @since 0.1.33\n * @async\n * @param {string|Buffer|URL} pathToDir\n * @param {boolean=} excludeSystemFiles\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function dirIsEmpty(pathToDir, excludeSystemFiles = true) {\n  let contents = await listContents(pathToDir);\n  if (!Array.isArray(contents)) {\n    return contents;\n  }\n  if (contents.length === 0) {\n    return true;\n  }\n  if (!excludeSystemFiles) {\n    return false;\n  }\n  for (let contentIndex = 0; contentIndex < contents.length; contentIndex += 1) {\n    for (let excludeIndex = 0; excludeIndex < EXCLUDE.length; excludeIndex += 1) {\n      if (!contents[contentIndex]) {\n        continue;\n      }\n      if (\n        contents[contentIndex] === EXCLUDE[excludeIndex] ||\n        contents[contentIndex].match(RegExp(EXCLUDE[excludeIndex]))\n      ) {\n        delete contents[contentIndex];\n        contents = contents.filter((content) => content);\n      }\n    }\n  }\n  return contents.length === 0;\n}\n","import { promises } from \"fs\";\n\nimport { ofError } from \"@await-of/of\";\n\n/**\n * @name accessWrapper\n * @description Asynchronously tests a user's permissions for the file specified by path.\n * @since 0.0.1\n * @async\n * @param {number} mode\n * @param {string|Buffer|URL} path\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function accessWrapper(mode, path) {\n  const fsError = await ofError(promises.access(path, mode));\n  if (!fsError) {\n    return true;\n  }\n  return fsError;\n}\n","import { constants } from \"fs\";\n\nimport { accessWrapper } from \"../access/wrapper.js\";\n\n/**\n * @name dirIsExecutable\n * @description Directory can be executed by the calling process\n * @since 0.0.5\n * @async\n * @param {string|Buffer|URL} pathToDir\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function dirIsExecutable(pathToDir) {\n  return accessWrapper(constants.X_OK, pathToDir);\n}\n","import { constants } from \"fs\";\n\nimport { accessWrapper } from \"../access/wrapper.js\";\n\n/**\n * @name dirIsReadable\n * @description Directory is visible to the calling process\n * @since 0.0.1\n * @async\n * @param {string|Buffer|URL} pathToDir\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function dirIsReadable(pathToDir) {\n  return accessWrapper(constants.R_OK, pathToDir);\n}\n","import { constants } from \"fs\";\n\nimport { accessWrapper } from \"../access/wrapper.js\";\n\n/**\n * @name dirIsVisible\n * @description Directory is visible to the calling process\n * @since 0.0.5\n * @async\n * @param {string|Buffer|URL} pathToDir\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function dirIsVisible(pathToDir) {\n  return accessWrapper(constants.F_OK, pathToDir);\n}\n","import { constants } from \"fs\";\n\nimport { accessWrapper } from \"../access/wrapper.js\";\n\n/**\n * @name dirIsWritable\n * @description Directory can be written by the calling process\n * @since 0.0.1\n * @async\n * @param {string|Buffer|URL} pathToDir\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function dirIsWritable(pathToDir) {\n  return accessWrapper(constants.W_OK, pathToDir);\n}\n","import { constants } from \"fs\";\n\nimport { accessWrapper } from \"../access/wrapper.js\";\n\n/**\n * @name fileIsExecutable\n * @description File can be executed by the calling process\n * @since 0.0.5\n * @async\n * @param {string|Buffer|URL} pathToFile\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function fileIsExecutable(pathToFile) {\n  return accessWrapper(constants.X_OK, pathToFile);\n}\n","import { constants } from \"fs\";\n\nimport { accessWrapper } from \"../access/wrapper.js\";\n\n/**\n * @name fileIsReadable\n * @description File is visible to the calling process\n * @since 0.0.1\n * @async\n * @param {string|Buffer|URL} pathToFile\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function fileIsReadable(pathToFile) {\n  return accessWrapper(constants.R_OK, pathToFile);\n}\n","import { constants } from \"fs\";\n\nimport { accessWrapper } from \"../access/wrapper.js\";\n\n/**\n * @name fileIsVisible\n * @description File is visible to the calling process\n * @since 0.0.5\n * @async\n * @param {string|Buffer|URL} pathToFile\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function fileIsVisible(pathToFile) {\n  return accessWrapper(constants.F_OK, pathToFile);\n}\n","import { constants } from \"fs\";\n\nimport { accessWrapper } from \"../access/wrapper.js\";\n\n/**\n * @name fileIsWritable\n * @description File can be written by the calling process\n * @since 0.0.1\n * @async\n * @param {string|Buffer|URL} pathToFile\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function fileIsWritable(pathToFile) {\n  return accessWrapper(constants.W_OK, pathToFile);\n}\n","import { promises } from \"fs\";\n\nimport { ofError } from \"@await-of/of\";\n\n/**\n * @name fileTruncate\n * @description Truncate a file to a specified length\n * @since 0.0.6\n * @async\n * @param {string|Buffer|URL} pathToFile\n * @param {number=} length\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function fileTruncate(pathToFile, length = 0) {\n  const fsError = await ofError(promises.truncate(pathToFile, length));\n  if (!fsError) {\n    return true;\n  }\n  return fsError;\n}\n","import { join } from \"path\";\n\n/**\n * @name pathFrom\n * @description Join all arguments together and normalize the resulting path.\n * @since 0.1.3\n * @param {string|Array.<string>} paths\n * @param {...string} morePaths\n * @returns {string}\n */\nexport function pathFrom(paths, ...morePaths) {\n  let routes;\n  if (Array.isArray(paths)) {\n    routes = paths.map((path) => path.toString());\n  } else {\n    routes = [paths.toString()];\n  }\n  if (morePaths.length) {\n    routes = routes.concat(morePaths.map((path) => path.toString()));\n  }\n  return join(...routes);\n}\n","import { getStatus } from \"../status/getStatus.js\";\nimport { listContents } from \"./contents.js\";\nimport { pathFrom } from \"../path/pathFrom.js\";\n\n/**\n * @name listDirectories\n * @description Lists directories in path\n * @since 0.1.32\n * @async\n * @param {string|Buffer|URL} pathToDir\n * @returns {Promise<Array.<string>|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function listDirectories(pathToDir) {\n  const contents = await listContents(pathToDir);\n  if (!Array.isArray(contents)) {\n    return contents;\n  }\n  const directories = await Promise.all(\n    contents.map(async (content) => {\n      const contentPath = pathFrom(pathToDir, content);\n      const [status, error] = await getStatus(contentPath);\n      if (error) {\n        return undefined;\n      }\n      if (!status.isDirectory()) {\n        return undefined;\n      }\n      return content;\n    }),\n  );\n  return directories.filter((content) => content);\n}\n","import { getStatus } from \"../status/getStatus.js\";\nimport { listContents } from \"./contents.js\";\nimport { pathFrom } from \"../path/pathFrom.js\";\n\n/**\n * @name listFiles\n * @description Lists files in path\n * @since 0.1.32\n * @async\n * @param {string|Buffer|URL} pathToDir\n * @returns {Promise<Array.<string>|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function listFiles(pathToDir) {\n  const contents = await listContents(pathToDir);\n  if (!Array.isArray(contents)) {\n    return contents;\n  }\n  const files = await Promise.all(\n    contents.map(async (content) => {\n      const contentPath = pathFrom(pathToDir, content);\n      const [status, error] = await getStatus(contentPath);\n      if (error) {\n        return undefined;\n      }\n      if (status.isDirectory()) {\n        return undefined;\n      }\n      return content;\n    }),\n  );\n  return files.filter((content) => content);\n}\n","import { promises } from \"fs\";\n\nimport { ofError } from \"@await-of/of\";\n\n/**\n * @name move\n * @description Change the name or location of a file or directory.\n * @since 0.1.29\n * @param {string} pathFrom\n * @param {string} pathTo\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function move(pathFrom, pathTo) {\n  const errorRename = await ofError(promises.rename(pathFrom, pathTo));\n  if (errorRename) {\n    return errorRename;\n  }\n  return true;\n}\n","import { resolve } from \"path\";\n\n/**\n * @name absolutePathFrom\n * @description Join all arguments together and normalize the resulting path.\n * Creates absolute path from right to left until an absolute path is constructed.\n * @since 0.1.5\n * @param {String|Array.<string>} paths\n * @param {...String} morePaths\n * @returns {String}\n */\nexport function absolutePathFrom(paths, ...morePaths) {\n  let routes;\n  if (Array.isArray(paths)) {\n    routes = paths.map((path) => path.toString());\n  } else {\n    routes = [paths.toString()];\n  }\n  if (morePaths.length) {\n    routes = routes.concat(morePaths.map((path) => path.toString()));\n  }\n  return resolve(...routes);\n}\n","import { extname } from \"path\";\n\n/**\n * @name fileExtension\n * @description Get file extension.\n * @since 0.1.1\n * @param {string} path\n * @returns {string}\n */\nexport function fileExtension(path) {\n  return extname(path).substring(1);\n}\n","import { parse } from \"path\";\n\n/**\n * @name fileName\n * @description Return the file name without extension.\n * @since 0.1.1\n * @param {string} path\n * @returns {string}\n */\nexport function fileName(path) {\n  return parse(path).name;\n}\n","import { basename } from \"path\";\n\n/**\n * @name fileNameExt\n * @description Return the last portion of a path.\n * @since 0.1.1\n * @param {string} path\n * @returns {string}\n */\nexport function fileNameExt(path) {\n  return basename(path);\n}\n","import { dirname } from \"path\";\n\n/**\n * @name filePath\n * @description Return the directory name of a path.\n * @since 0.1.1\n * @param {string} path\n * @returns {string}\n */\nexport function filePath(path) {\n  return dirname(path);\n}\n","import { promises } from \"fs\";\n\nimport { of } from \"@await-of/of\";\n\n/**\n * @name readFileToBase64\n * @description Asynchronously reads the entire contents of a file into string.\n * @since 0.1.21\n * @async\n * @param {string|Buffer|URL} pathLike\n * @returns {Promise<string|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function readFileToBase64(pathLike) {\n  const [result, error] = await of(promises.readFile(pathLike, \"base64\"));\n  if (error) {\n    return error;\n  }\n  return result.toString();\n}\n","import { promises } from \"fs\";\n\nimport { of } from \"@await-of/of\";\n\n/**\n * @name readFileToBuffer\n * @description Asynchronously reads the entire contents of a file into buffer.\n * @since 0.1.19\n * @async\n * @param {string|Buffer|URL} pathLike\n * @returns {Promise<Buffer|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function readFileToBuffer(pathLike) {\n  const [result, error] = await of(promises.readFile(pathLike, \"binary\"));\n  if (error) {\n    return error;\n  }\n  return Buffer.from(result);\n}\n","import { promises } from \"fs\";\n\nimport { of } from \"@await-of/of\";\n\n/**\n * @name readFileToString\n * @description Asynchronously reads the entire contents of a file into string.\n * @since 0.1.7\n * @async\n * @param {string|Buffer|URL} pathLike\n * @returns {Promise<string|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function readFileToString(pathLike) {\n  const [result, error] = await of(promises.readFile(pathLike, \"utf8\"));\n  if (error) {\n    return error;\n  }\n  return result.toString();\n}\n","import * as fs from \"fs\";\nimport assert from \"assert\";\nimport path from \"path\";\n\nconst IS_WINDOWS = process.platform === \"win32\";\n\n/**\n * @param {object} options\n */\nfunction defaults(options) {\n  const methods = [\"unlink\", \"chmod\", \"stat\", \"lstat\", \"rmdir\", \"readdir\"];\n  methods.forEach((method) => {\n    options[method] = options[method] || fs[method];\n  });\n  options.maxBusyTries = options.maxBusyTries || 3;\n}\n\n/**\n * @param {string} pathLike\n * @param {Function|object=} options\n * @param {Function=} callback\n */\nfunction rimraf(pathLike, options, callback) {\n  let busyTries = 0;\n  let localCallback = callback;\n  let localOptions = options;\n  if (typeof localOptions === \"function\") {\n    localCallback = localOptions;\n    localOptions = {};\n  }\n  assert(pathLike, \"remove(): missing path\");\n  assert.strictEqual(typeof pathLike, \"string\", \"remove(): path should be a string\");\n  assert.strictEqual(typeof localCallback, \"function\", \"remove(): callback function required\");\n  assert(localOptions, \"remove(): invalid options argument provided\");\n  assert.strictEqual(typeof localOptions, \"object\", \"remove(): options should be object\");\n  defaults(localOptions);\n  rimraf_(pathLike, localOptions, function callbackRimraf(error) {\n    if (error) {\n      if (\n        (error.code === \"EBUSY\" || error.code === \"ENOTEMPTY\" || error.code === \"EPERM\") &&\n        busyTries < localOptions.maxBusyTries\n      ) {\n        busyTries++;\n        const time = busyTries * 100;\n        setTimeout(() => rimraf_(pathLike, localOptions, callbackRimraf), time);\n        return;\n      }\n      if (error.code === \"ENOENT\") {\n        localCallback(null);\n        return;\n      }\n    }\n    localCallback(error);\n  });\n}\n\n/**\n * @param {string} pathLike\n * @param {Function|object=} options\n * @param {Function=} callback\n */\nfunction rimraf_(pathLike, options, callback) {\n  assert(pathLike);\n  assert(options);\n  assert(typeof callback === \"function\");\n  options.lstat(pathLike, (error, stats) => {\n    if (error && error.code === \"ENOENT\") {\n      return callback(null);\n    }\n    if (error && error.code === \"EPERM\" && IS_WINDOWS) {\n      return fixWinEPERM(pathLike, options, error, callback);\n    }\n    if (stats && stats.isDirectory()) {\n      return rmdir(pathLike, options, error, callback);\n    }\n    options.unlink(pathLike, (error) => {\n      if (error) {\n        if (error.code === \"ENOENT\") {\n          return callback(null);\n        }\n        if (error.code === \"EPERM\") {\n          if (IS_WINDOWS) {\n            return fixWinEPERM(pathLike, options, error, callback);\n          } else {\n            return rmdir(pathLike, options, error, callback);\n          }\n        }\n        if (error.code === \"EISDIR\") {\n          return rmdir(pathLike, options, error, callback);\n        }\n      }\n      return callback(error);\n    });\n  });\n}\n\n/**\n * @param {string} pathLike\n * @param {Function|object=} options\n * @param {Error|null} error\n * @param {Function=} callback\n * @returns {null}\n */\nfunction fixWinEPERM(pathLike, options, error, callback) {\n  assert(pathLike);\n  assert(options);\n  assert(typeof callback === \"function\");\n  if (error) {\n    assert(error instanceof Error);\n  }\n  options.chmod(pathLike, 0o666, (errorChMod) => {\n    if (errorChMod) {\n      if (errorChMod.code === \"ENOENT\") {\n        callback(null);\n      } else {\n        callback(error);\n      }\n    } else {\n      options.stat(pathLike, (errorStat, stats) => {\n        if (errorStat) {\n          if (errorStat.code === \"ENOENT\") {\n            callback(null);\n          } else {\n            callback(error);\n          }\n        } else if (stats.isDirectory()) {\n          rmdir(pathLike, options, error, callback);\n        } else {\n          options.unlink(pathLike, callback);\n        }\n      });\n    }\n  });\n  return null;\n}\n\n/**\n * @param {string} pathLike\n * @param {Function|object=} options\n * @param {Error|null} originalError\n * @param {Function=} callback\n * @returns {null}\n */\nfunction rmdir(pathLike, options, originalError, callback) {\n  assert(pathLike);\n  assert(options);\n  if (originalError) {\n    assert(originalError instanceof Error);\n  }\n  assert(typeof callback === \"function\");\n  options.rmdir(pathLike, (error) => {\n    if (error && (error.code === \"ENOTEMPTY\" || error.code === \"EEXIST\" || error.code === \"EPERM\")) {\n      removeSubPath(pathLike, options, callback);\n    } else if (error && error.code === \"ENOTDIR\") {\n      callback(originalError);\n    } else {\n      callback(error);\n    }\n  });\n  return null;\n}\n\n/**\n * @param {string} pathLike\n * @param {Function|object=} options\n * @param {Function=} callback\n */\nfunction removeSubPath(pathLike, options, callback) {\n  assert(pathLike);\n  assert(options);\n  assert(typeof callback === \"function\");\n  options.readdir(pathLike, (error, files) => {\n    if (error) {\n      return callback(error);\n    }\n    let count = files.length;\n    let errState;\n    if (count === 0) {\n      return options.rmdir(pathLike, callback);\n    }\n    files.forEach((filePath) => {\n      rimraf(path.join(pathLike, filePath), options, (error) => {\n        if (errState) {\n          return;\n        }\n        if (error) {\n          callback((errState = error));\n          return;\n        }\n        --count;\n        if (count === 0) {\n          options.rmdir(pathLike, callback);\n        }\n      });\n    });\n  });\n}\n\n/**\n * @name remove\n * @description Removes a file or directory.\n * @since 0.1.1\n * @async\n * @param {string} pathLike\n * @returns {Promise<undefined|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function remove(pathLike) {\n  return new Promise((resolve, reject) => {\n    rimraf(pathLike, {}, (error) => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n","import { remove } from \"./remove.js\";\n\n/**\n * @name removeNonBlocking\n * @description Non-blocking remove of a file or directory.\n * @since 0.1.18\n * @param {string} pathLike\n * @returns {void}\n */\nexport function removeNonBlocking(pathLike) {\n  remove(pathLike)\n    .then(() => undefined)\n    .catch(() => undefined); // don't put it into next tick\n}\n","import { getStatus } from \"./getStatus.js\";\n\n/**\n * @name isDirExists\n * @description Get directory status.\n * @since 0.0.11\n * @async\n * @param {string|Buffer|URL} path\n * @returns {Promise<boolean>}\n */\nexport async function isDirExists(path) {\n  const [status, error] = await getStatus(path);\n  if (error) {\n    return false;\n  }\n  return status.isDirectory();\n}\n","import { getStatus } from \"./getStatus.js\";\n\n/**\n * @name isFileExists\n * @description Get file status.\n * @since 0.0.11\n * @async\n * @param {string|Buffer|URL} path\n * @returns {Promise<boolean>}\n */\nexport async function isFileExists(path) {\n  const [status, error] = await getStatus(path);\n  if (error) {\n    return false;\n  }\n  return status.isFile();\n}\n","import { getStatus } from \"./getStatus.js\";\n\n/**\n * @name isPathExists\n * @description Get path status.\n * @since 0.0.11\n * @async\n * @param {string|Buffer|URL} path\n * @returns {Promise<boolean>}\n */\nexport async function isPathExists(path) {\n  const [status] = await getStatus(path);\n  return Boolean(status);\n}\n","import { writeFile } from \"./writeFile.js\";\n\n/**\n * @name writeJSON\n * @description Asynchronously writes data to a file, replacing the file if it already exists.\n * @since 0.1.25\n * @async\n * @param {string|Buffer|URL} filePath\n * @param {*} data\n * @param {*|null|string=} options\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function writeJSON(filePath, data, options) {\n  let json;\n  try {\n    json = JSON.stringify(data);\n  } catch (error) {\n    return error;\n  }\n  return writeFile(filePath, json, options);\n}\n","import { absolutePathFrom } from \"./path/absolutePathFrom.js\";\nimport { createDirectory } from \"./create/createDirectory.js\";\nimport { createFile } from \"./create/createFile.js\";\nimport { dirIsExecutable } from \"./dir/dirIsExecutable.js\";\nimport { dirIsReadable } from \"./dir/dirIsReadable.js\";\nimport { dirIsVisible } from \"./dir/dirIsVisible.js\";\nimport { dirIsWritable } from \"./dir/dirIsWritable.js\";\nimport { dirIsEmpty } from \"./dir/dirIsEmpty.js\";\nimport { fileExtension } from \"./path/fileExtension.js\";\nimport { fileIsExecutable } from \"./file/fileIsExecutable.js\";\nimport { fileIsReadable } from \"./file/fileIsReadable.js\";\nimport { fileIsVisible } from \"./file/fileIsVisible.js\";\nimport { fileIsWritable } from \"./file/fileIsWritable.js\";\nimport { fileName } from \"./path/fileName.js\";\nimport { fileNameExt } from \"./path/fileNameExt.js\";\nimport { filePath } from \"./path/filePath.js\";\nimport { fileTruncate } from \"./file/fileTruncate.js\";\nimport { listContents } from \"./list/contents.js\";\nimport { listDirectories } from \"./list/directories.js\";\nimport { listFiles } from \"./list/files.js\";\nimport { getStatus } from \"./status/getStatus.js\";\nimport { isDirExists } from \"./status/isDirExists.js\";\nimport { isFileExists } from \"./status/isFileExists.js\";\nimport { isPathExists } from \"./status/isPathExists.js\";\nimport { move } from \"./move/move.js\";\nimport { pathFrom } from \"./path/pathFrom.js\";\nimport { readFileToBase64 } from \"./read/readFileToBase64.js\";\nimport { readFileToBuffer } from \"./read/readFileToBuffer.js\";\nimport { readFileToString } from \"./read/readFileToString.js\";\nimport { remove } from \"./remove/remove.js\";\nimport { removeNonBlocking } from \"./remove/removeNonBlocking.js\";\nimport { writeFile } from \"./write/writeFile.js\";\nimport { writeJSON } from \"./write/writeJSON.js\";\n\nexport class HileSystemLocal {\n  /**\n   * @name absolutePathFrom\n   * @description Join all arguments together and normalize the resulting path.\n   * reates absolute path from right to left until an absolute path is constructed.\n   * @since 0.1.5\n   * @public\n   * @param {string|Array.<string>} paths\n   * @param {...string} morePaths\n   * @returns {string}\n   */\n  absolutePathFrom = absolutePathFrom;\n  /**\n   * @name createDirectory\n   * @description Asynchronous create a directory.\n   * @since 0.0.10\n   * @async\n   * @public\n   * @param {string|Buffer|URL} dirPath\n   * @param {number|string=} mode\n   * @param {boolean=} recursive\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  createDirectory = createDirectory;\n  /**\n   * @name createFile\n   * @description Asynchronous create a file.\n   * @since 0.0.11\n   * @async\n   * @public\n   * @param {string|Buffer|URL} pathLike\n   * @param {number|string=} mode\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  createFile = createFile;\n  /**\n   * @name dirIsExecutable\n   * @description Directory can be executed by the calling process\n   * @since 0.0.5\n   * @async\n   * @public\n   * @param {string} pathToDir\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  dirIsExecutable = dirIsExecutable;\n  /**\n   * @name dirIsReadable\n   * @description Directory is visible to the calling process\n   * @since 0.0.1\n   * @async\n   * @public\n   * @param {string} pathToDir\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  dirIsReadable = dirIsReadable;\n  /**\n   * @name dirIsVisible\n   * @description Directory is visible to the calling process\n   * @since 0.0.5\n   * @async\n   * @public\n   * @param {string} pathToDir\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  dirIsVisible = dirIsVisible;\n  /**\n   * @name dirIsWritable\n   * @description Directory can be written by the calling process\n   * @since 0.0.1\n   * @async\n   * @public\n   * @param {string} pathToDir\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  dirIsWritable = dirIsWritable;\n  /**\n   * @name dirIsEmpty\n   * @description Check if a directory is empty\n   * @since 0.1.33\n   * @async\n   * @public\n   * @param {string|Buffer|URL} pathToDir\n   * @param {boolean=} excludeSystemFiles\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  dirIsEmpty = dirIsEmpty;\n  /**\n   * @name getStatus\n   * @description Get file status.\n   * @since 0.0.11\n   * @async\n   * @public\n   * @param {string|Buffer|URL} path\n   * @returns {Promise<Array.<(object|undefined|Error|{name: string, message: string, stack?: string})>>}\n   */\n  getStatus = getStatus;\n  /**\n   * @name isDirExists\n   * @description Get directory status.\n   * @since 0.0.11\n   * @async\n   * @public\n   * @param {string|Buffer|URL} path\n   * @returns {Promise<boolean>}\n   */\n  isDirExists = isDirExists;\n  /**\n   * @name isFileExists\n   * @description Get file status.\n   * @since 0.0.11\n   * @async\n   * @public\n   * @param {string|Buffer|URL} path\n   * @returns {Promise<boolean>}\n   */\n  isFileExists = isFileExists;\n  /**\n   * @name isPathExists\n   * @description Get path status.\n   * @since 0.0.11\n   * @async\n   * @public\n   * @param {string|Buffer|URL} path\n   * @returns {Promise<boolean>}\n   */\n  isPathExists = isPathExists;\n  /**\n   * @name fileExtension\n   * @description Get file extension.\n   * @since 0.1.1\n   * @public\n   * @param {string} path\n   * @returns {string}\n   */\n  fileExtension = fileExtension;\n  /**\n   * @name fileName\n   * @description Return the file name without extension.\n   * @since 0.1.1\n   * @public\n   * @param {string} path\n   * @returns {string}\n   */\n  fileName = fileName;\n  /**\n   * @name fileNameExt\n   * @description Return the last portion of a path.\n   * @since 0.1.1\n   * @public\n   * @param {string} path\n   * @returns {string}\n   */\n  fileNameExt = fileNameExt;\n  /**\n   * @name filePath\n   * @description Return the directory name of a path.\n   * @since 0.1.1\n   * @public\n   * @param {string} path\n   * @returns {string}\n   */\n  filePath = filePath;\n  /**\n   * @name fileIsExecutable\n   * @description File can be executed by the calling process\n   * @since 0.0.5\n   * @async\n   * @public\n   * @param {string|Buffer|URL} pathToFile\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  fileIsExecutable = fileIsExecutable;\n  /**\n   * @name fileIsReadable\n   * @description File is visible to the calling process\n   * @since 0.0.1\n   * @async\n   * @public\n   * @param {string|Buffer|URL} pathToFile\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  fileIsReadable = fileIsReadable;\n  /**\n   * @name fileIsVisible\n   * @description File is visible to the calling process\n   * @since 0.0.5\n   * @async\n   * @public\n   * @param {string|Buffer|URL} pathToFile\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  fileIsVisible = fileIsVisible;\n  /**\n   * @name fileIsWritable\n   * @description File can be written by the calling process\n   * @since 0.0.1\n   * @async\n   * @public\n   * @param {string|Buffer|URL} pathToFile\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  fileIsWritable = fileIsWritable;\n  /**\n   * @name fileTruncate\n   * @description Truncate a file to a specified length\n   * @since 0.0.6\n   * @async\n   * @public\n   * @param {string|Buffer|URL} pathToFile\n   * @param {number=} length\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  fileTruncate = fileTruncate;\n  /**\n   * @name listContents\n   * @description Lists files and directories in path\n   * @since 0.1.32\n   * @async\n   * @param {string|Buffer|URL} pathToDir\n   * @returns {Promise<Array.<string>|Error|{name: string, message: string, stack?: string}>}\n   */\n  listContents = listContents;\n  /**\n   * @name listDirectories\n   * @description Lists directories in path\n   * @since 0.1.32\n   * @async\n   * @param {string|Buffer|URL} pathToDir\n   * @returns {Promise<Array.<string>|Error|{name: string, message: string, stack?: string}>}\n   */\n  listDirectories = listDirectories;\n  /**\n   * @name listFiles\n   * @description Lists files in path\n   * @since 0.1.32\n   * @async\n   * @param {string|Buffer|URL} pathToDir\n   * @returns {Promise<Array.<string>|Error|{name: string, message: string, stack?: string}>}\n   */\n  listFiles = listFiles;\n  /**\n   * @name move\n   * @description Change the name or location of a file or directory.\n   * @since 0.1.29\n   * @public\n   * @param {string} pathFrom\n   * @param {string} pathTo\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  move = move;\n  /**\n   * @name pathFrom\n   * @description Join all arguments together and normalize the resulting path.\n   * @since 0.1.3\n   * @public\n   * @param {string|Array.<string>} paths\n   * @param {...string} morePaths\n   * @returns {string}\n   */\n  pathFrom = pathFrom;\n  /**\n   * @name readFileToBase64\n   * @description Asynchronously reads the entire contents of a file into string.\n   * @since 0.1.21\n   * @async\n   * @param {string|Buffer|URL} pathLike\n   * @returns {Promise<string|Error|{name: string, message: string, stack?: string}>}\n   */\n  readFileToBase64 = readFileToBase64;\n  /**\n   * @name readFileToBuffer\n   * @description Asynchronously reads the entire contents of a file into buffer.\n   * @since 0.1.19\n   * @async\n   * @param {string|Buffer|URL} pathLike\n   * @returns {Promise<Buffer|Error|{name: string, message: string, stack?: string}>}\n   */\n  readFileToBuffer = readFileToBuffer;\n  /**\n   * @name readFileToString\n   * @description Asynchronously reads the entire contents of a file into string.\n   * @since 0.1.7\n   * @async\n   * @param {string|Buffer|URL} pathLike\n   * @returns {Promise<string|Error|{name: string, message: string, stack?: string}>}\n   */\n  readFileToString = readFileToString;\n  /**\n   * @name remove\n   * @description Removes a file or directory.\n   * @since 0.1.1\n   * @async\n   * @public\n   * @param {string} pathLike\n   * @returns {Promise<undefined|Error|{name: string, message: string, stack?: string}>}\n   */\n  remove = remove;\n  /**\n   * @name removeNonBlocking\n   * @description Non-blocking remove of a file or directory.\n   * @since 0.1.18\n   * @public\n   * @param {string} pathLike\n   * @returns {void}\n   */\n  removeNonBlocking = removeNonBlocking;\n  /**\n   * @name writeFile\n   * @description Asynchronously writes data to a file, replacing the file if it already exists.\n   * @since 0.0.10\n   * @async\n   * @public\n   * @param {string|Buffer|URL} filePath\n   * @param {string} data\n   * @param {*|null|string=} options\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  writeFile = writeFile;\n  /**\n   * @name writeJSON\n   * @description Asynchronously writes data to a file, replacing the file if it already exists.\n   * @since 0.1.25\n   * @async\n   * @public\n   * @param {string|Buffer|URL} filePath\n   * @param {*} data\n   * @param {*|null|string=} options\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  writeJSON = writeJSON;\n}\n"],"names":["async","createDirectory","dirPath","mode","recursive","dirError","ofError","promises","mkdir","getStatus","path","of","stat","writeFile","filePath","data","options","writeError","createFile","pathLike","status","error","isFile","dirname","code","dirCreated","fileWritten","flag","isDirectory","readdir","listContents","pathToDir","contents","fsError","ofAny","EXCLUDE","dirIsEmpty","excludeSystemFiles","Array","isArray","length","contentIndex","excludeIndex","match","RegExp","filter","content","accessWrapper","access","dirIsExecutable","constants","X_OK","dirIsReadable","R_OK","dirIsVisible","F_OK","dirIsWritable","W_OK","fileIsExecutable","pathToFile","fileIsReadable","fileIsVisible","fileIsWritable","fileTruncate","truncate","pathFrom","paths","morePaths","routes","map","toString","concat","join","listDirectories","Promise","all","contentPath","listFiles","move","pathTo","errorRename","rename","absolutePathFrom","resolve","fileExtension","extname","substring","fileName","parse","name","fileNameExt","basename","readFileToBase64","result","readFile","readFileToBuffer","Buffer","from","readFileToString","IS_WINDOWS","process","platform","rimraf","callback","busyTries","localCallback","localOptions","assert","strictEqual","defaults","forEach","method","fs","maxBusyTries","rimraf_","callbackRimraf","setTimeout","lstat","stats","fixWinEPERM","rmdir","unlink","Error","chmod","errorChMod","errorStat","originalError","removeSubPath","files","errState","count","remove","reject","removeNonBlocking","then","catch","isDirExists","isFileExists","isPathExists","Boolean","writeJSON","json","JSON","stringify","HileSystemLocal"],"mappings":"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"}