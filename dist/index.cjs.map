{"version":3,"file":"index.cjs","sources":["../src/core/create/createDirectory.js","../src/core/status/getStatus.js","../src/core/write/writeFile.js","../src/core/create/createFile.js","../src/core/access/wrapper.js","../src/core/dir/dirIsReadable.js","../src/core/list/is-system-junk.js","../src/core/list/is-not-system-junk.js","../src/core/list/contents.js","../src/core/dir/dirIsEmpty.js","../src/core/error/errorExtractOptions.js","../src/core/dir/dirIsExecutable.js","../src/core/dir/dirIsVisible.js","../src/core/dir/dirIsWritable.js","../src/core/info/hash.js","../src/core/info/hash-crc32.js","../src/core/info/hash-md5.js","../src/core/info/hash-sha1.js","../src/core/info/hash-sha256.js","../src/core/info/hash-sha512.js","../src/core/info/size.js","../src/core/file/fileIsExecutable.js","../src/core/file/fileIsReadable.js","../src/core/file/fileIsVisible.js","../src/core/file/fileIsWritable.js","../src/core/file/fileTruncate.js","../src/core/path/pathFrom.js","../src/core/list/directories.js","../src/core/list/files.js","../src/core/move/move.js","../src/core/path/absolutePath.js","../src/core/path/absolutePathFrom.js","../src/core/path/fileExtension.js","../src/core/path/fileName.js","../src/core/path/fileNameExt.js","../src/core/path/filePath.js","../src/core/read/readFileToBase64.js","../src/core/read/readFileToBuffer.js","../src/core/read/readFileToString.js","../src/core/remove/remove.js","../src/core/remove/removeNonBlocking.js","../src/core/remove/removeSilent.js","../src/core/status/getLinkStatus.js","../src/core/status/isDirExists.js","../src/core/status/isFileExists.js","../src/core/status/isPathExists.js","../src/core/write/writeFileTail.js","../src/core/write/writeJSON.js","../src/core/HileSystemLocal.js"],"sourcesContent":["import { mkdir } from \"node:fs/promises\";\n\n/**\n * @name createDirectory\n * @description Asynchronous create a directory.\n * @since 0.0.10\n * @async\n * @param {string|Buffer|URL} dirPath\n * @param {number|string=} mode\n * @param {boolean=} recursive\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function createDirectory(dirPath, mode = \"0777\", recursive = true) {\n  try {\n    await mkdir(dirPath, { mode, recursive });\n    return true;\n  } catch (error) {\n    return error;\n  }\n}\n","import { stat } from \"node:fs/promises\";\n\n/**\n * @name getStatus\n * @description Get file status.\n * @since 0.0.11\n * @async\n * @param {string|Buffer|URL} path\n * @returns {Promise<Array.<(object|undefined|Error|{name: string, message: string, stack?: string})>>}\n */\nexport async function getStatus(path) {\n  try {\n    return [await stat(path)];\n  } catch (error) {\n    return [undefined, error];\n  }\n}\n","import { writeFile as writeFileNative } from \"node:fs/promises\";\n\n/**\n * @name writeFile\n * @description Asynchronously writes data to a file, replacing the file if it already exists.\n * @since 0.0.10\n * @async\n * @param {string|Buffer|URL} filePath\n * @param {string} data\n * @param {*|null|string=} options\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n * @example\n * const controller = new AbortController();\n * const { signal } = controller;\n * const data = new Uint8Array(Buffer.from('Hello Node.js'));\n * (async () => {\n *  try {\n *     await writeFile('message.txt', data, { signal });\n *   } catch (error) {\n *     // When a request is aborted - error is an AbortError\n *   }\n * })();\n * // When the request should be aborted\n * controller.abort();\n */\nexport async function writeFile(filePath, data, options) {\n  try {\n    await writeFileNative(filePath, data, options);\n    return true;\n  } catch (error) {\n    return error;\n  }\n}\n","import { dirname } from \"node:path\";\nimport { readdir } from \"node:fs/promises\";\n\nimport { createDirectory } from \"./createDirectory.js\";\nimport { getStatus } from \"../status/getStatus.js\";\nimport { writeFile } from \"../write/writeFile.js\";\n\n/**\n * @name createFile\n * @description Asynchronous create a file.\n * @since 0.0.11\n * @async\n * @param {string|Buffer|URL} pathLike\n * @param {number|string=} mode\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function createFile(pathLike, mode = \"0777\") {\n  const [status, error] = await getStatus(pathLike);\n  if (!error && status.isFile()) {\n    return true;\n  }\n  const dirPath = dirname(pathLike);\n  if (error) {\n    if (error.code === \"ENOENT\") {\n      const dirCreated = await createDirectory(dirPath, mode);\n      if (dirCreated !== true) {\n        return dirCreated;\n      }\n      const fileWritten = await writeFile(pathLike, \"\", { mode, flag: \"w\" });\n      if (fileWritten !== true) {\n        return fileWritten;\n      }\n      return true;\n    }\n  }\n  if (status.isDirectory()) {\n    return await writeFile(pathLike, \"\", { mode, flag: \"w\" });\n  } else {\n    try {\n      await readdir(dirPath);\n      return undefined;\n    } catch (error) {\n      return error;\n    }\n  }\n}\n","import { access } from \"node:fs/promises\";\n\n/**\n * @name accessWrapper\n * @description Asynchronously tests a user's permissions for the file specified by path.\n * @since 0.0.1\n * @async\n * @param {number} mode\n * @param {string|Buffer|URL} path\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function accessWrapper(mode, path) {\n  try {\n    await access(path, mode);\n    return true;\n  } catch (error) {\n    return error;\n  }\n}\n","import { constants } from \"node:fs\";\n\nimport { accessWrapper } from \"../access/wrapper.js\";\n\n/**\n * @name dirIsReadable\n * @description Directory is visible to the calling process\n * @since 0.0.1\n * @async\n * @param {string|Buffer|URL} pathToDir\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function dirIsReadable(pathToDir) {\n  return accessWrapper(constants.R_OK, pathToDir);\n}\n","// keep updated https://github.com/sindresorhus/junk\n\nconst ignoreList = [\n  // # All\n  \"^npm-debug\\\\.log$\", // Error log for npm\n  \"^\\\\..*\\\\.swp$\", // Swap file for vim state\n\n  // # macOS\n  \"^\\\\.DS_Store$\", // Stores custom folder attributes\n  \"^\\\\.AppleDouble$\", // Stores additional file resources\n  \"^\\\\.LSOverride$\", // Contains the absolute path to the app to be used\n  \"^Icon\\\\r$\", // Custom Finder icon: http://superuser.com/questions/298785/icon-file-on-os-x-desktop\n  \"^\\\\._.*\", // Thumbnail\n  \"^\\\\.Spotlight-V100(?:$|\\\\/)\", // Directory that might appear on external disk\n  \"\\\\.Trashes\", // File that might appear on external disk\n  \"^__MACOSX$\", // Resource fork\n\n  // # Linux\n  \"~$\", // Backup file\n\n  // # Windows\n  \"^Thumbs\\\\.db$\", // Image file cache\n  \"^ehthumbs\\\\.db$\", // Folder config file\n  \"^Desktop\\\\.ini$\", // Stores custom folder attributes\n  \"@eaDir$\", // Synology Diskstation \"hidden\" folder where the server stores thumbnails\n  \"^\\\\$RECYCLE.BIN$\", // Special folder with columns like Date deleted and Original location\n  \"^System Volume Information$\",\n];\n\nexport const junkRegex = new RegExp(ignoreList.join(\"|\"));\n\n/**\n * @name isSystemJunk\n * @description Returns true if filename matches a system junk file.\n * @param {string} [fileName]\n * @returns {boolean}\n * @since 0.2.0\n */\nexport function isSystemJunk(fileName) {\n  return junkRegex.test(fileName);\n}\n","import { isSystemJunk } from \"./is-system-junk.js\";\n\n/**\n * @name isNotSystemJunk\n * @description Returns true if filename matches a system junk file.\n * @param {string} [fileName]\n * @returns {boolean}\n * @since 0.2.0\n */\nexport function isNotSystemJunk(fileName) {\n  return !isSystemJunk(fileName);\n}\n","import { readdir } from \"node:fs/promises\";\n\nimport { isNotSystemJunk } from \"./is-not-system-junk.js\";\n\n/**\n * @name listContents\n * @description Lists files and directories in path\n * @since 0.1.32\n * @async\n * @param {string|Buffer|URL} pathToDir\n * @param {boolean} [ignoreJunk=true]\n * @returns {Promise<Array.<string>|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function listContents(pathToDir, ignoreJunk = true) {\n  try {\n    const contents = await readdir(pathToDir);\n    if (ignoreJunk) {\n      return contents.filter(isNotSystemJunk);\n    }\n    return contents;\n  } catch (error) {\n    return error;\n  }\n}\n","import { errorExtractOptions } from \"../error/errorExtractOptions.js\";\nimport { dirIsReadable } from \"./dirIsReadable.js\";\nimport { listContents } from \"../list/contents.js\";\n\nconst EXCLUDE = [\n  // macOS\n  \".AppleDB\",\n  \".AppleDesktop\",\n  \".AppleDouble\",\n  \".DS_Store\",\n  \".DocumentRevisions-V100\",\n  \".LSOverride\",\n  \".Spotlight-V100\",\n  \".TemporaryItems\",\n  \".Trashes\",\n  \".VolumeIcon.icns\",\n  // \"._*\",\n  \".apdisk\",\n  \".com.apple.timemachine.donotpresent\",\n  \".fseventsd\",\n  \"Network Trash Folder\",\n  \"Temporary Items\",\n  // Windows\n  \"$RECYCLE.BIN/\",\n  // \"*.cab\",\n  // \"*.lnk\",\n  // \"*.msi\",\n  // \"*.msix\",\n  // \"*.msm\",\n  // \"*.msp\",\n  // \"*.stackdump\",\n  \"Desktop.ini\",\n  \"Thumbs.db\",\n  \"Thumbs.db:encryptable\",\n  \"desktop.ini\",\n  \"ehthumbs.db\",\n  \"ehthumbs_vista.db\",\n  // Linux\n  // \"*~\",\n  // \".Trash-*\",\n  \".directory\",\n  // \".fuse_hidden*\",\n  // \".nfs*\",\n];\n\n/**\n * @name isEmptyContent\n * @param {Array.<string>} listOfDirsAndFiles\n * @returns {boolean}\n */\nfunction isEmptyContent(listOfDirsAndFiles) {\n  const content = new Set(listOfDirsAndFiles);\n  listOfDirsAndFiles.length = 0;\n  content.forEach((dirOrFileName) => {\n    for (const nameToExclude of EXCLUDE) {\n      if (!dirOrFileName) {\n        continue;\n      }\n      if (dirOrFileName === nameToExclude || dirOrFileName.match(RegExp(nameToExclude))) {\n        content.delete(dirOrFileName);\n      }\n    }\n  });\n  return content.size === 0;\n}\n\n/**\n * @name dirIsEmpty\n * @description Check if a directory is empty\n * @since 0.1.33\n * @async\n * @param {string|Buffer|URL} pathToDir\n * @param {boolean=} excludeSystemFiles\n * @returns {Promise<boolean>}\n * @throws {Error} If path is not a dir or is not readable.\n */\nexport async function dirIsEmpty(pathToDir, excludeSystemFiles = true) {\n  const isReadableOrError = await dirIsReadable(pathToDir);\n  if (isReadableOrError !== true) {\n    throw new Error(isReadableOrError.message, errorExtractOptions(isReadableOrError));\n  }\n  let listOfDirsAndFiles = await listContents(pathToDir);\n  if (listOfDirsAndFiles instanceof Error) {\n    throw listOfDirsAndFiles;\n  }\n  if (listOfDirsAndFiles.length === 0) {\n    return true;\n  }\n  if (!excludeSystemFiles) {\n    return false;\n  }\n  return isEmptyContent(listOfDirsAndFiles);\n}\n","/**\n * @name errorExtractOptions\n * @param {Error} error\n * @returns {{ cause: Error } | { cause: { code?: string, values?: any[] | { [key: string]: any } }}}\n */\nexport function errorExtractOptions(error) {\n  if (!(error instanceof Error)) {\n    return { cause: error };\n  }\n  if (\"code\" in error && \"errno\" in error && \"path\" in error && \"syscall\" in error) {\n    return {\n      cause: {\n        code: error.code,\n        values: {\n          errno: error.errno,\n          path: error.path,\n          syscall: error.syscall,\n        },\n      },\n    };\n  }\n}\n","import { constants } from \"node:fs\";\n\nimport { accessWrapper } from \"../access/wrapper.js\";\n\n/**\n * @name dirIsExecutable\n * @description Directory can be executed by the calling process\n * @since 0.0.5\n * @async\n * @param {string|Buffer|URL} pathToDir\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function dirIsExecutable(pathToDir) {\n  return accessWrapper(constants.X_OK, pathToDir);\n}\n","import { constants } from \"node:fs\";\n\nimport { accessWrapper } from \"../access/wrapper.js\";\n\n/**\n * @name dirIsVisible\n * @description Directory is visible to the calling process\n * @since 0.0.5\n * @async\n * @param {string|Buffer|URL} pathToDir\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function dirIsVisible(pathToDir) {\n  return accessWrapper(constants.F_OK, pathToDir);\n}\n","import { constants } from \"node:fs\";\n\nimport { accessWrapper } from \"../access/wrapper.js\";\n\n/**\n * @name dirIsWritable\n * @description Directory can be written by the calling process\n * @since 0.0.1\n * @async\n * @param {string|Buffer|URL} pathToDir\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function dirIsWritable(pathToDir) {\n  return accessWrapper(constants.W_OK, pathToDir);\n}\n","import { createHash, getHashes } from \"node:crypto\";\nimport { readFile } from \"node:fs/promises\";\n\n/**\n * @name hash\n * @description Calculate hash.\n * @since 0.2.3\n * @async\n * @param {string|Buffer|URL} pathToFile\n * @param {string} algorithm\n * @returns {Promise<string|Error|{name: string, message: string, stack?: string}>}\n * @throws {TypeError} If algorithm is not supported.\n */\nexport async function hash(pathToFile, algorithm) {\n  if (!getHashes().includes(algorithm)) {\n    throw new TypeError(`Digest algorithm [${algorithm}] is not supported.`);\n  }\n  return createHash(algorithm)\n    .update(await readFile(pathToFile))\n    .digest(\"hex\");\n}\n","import { readFile } from \"node:fs/promises\";\n\nfunction crc32(text) {\n  let chars = [];\n  let actual;\n  for (let current = 0; current < 256; current++) {\n    actual = current;\n    for (let f = 0; f < 8; f++) {\n      actual = 1 & actual ? 3988292384 ^ (actual >>> 1) : actual >>> 1;\n    }\n    chars[current] = actual;\n  }\n  let number = -1;\n  let index = 0;\n  for (; index < text.length; index++) {\n    number = (number >>> 8) ^ chars[255 & (number ^ text.charCodeAt(index))];\n  }\n  return (-1 ^ number) >>> 0;\n}\n\n/**\n * @name hashCrc32\n * @description CRC32.\n * @since 0.2.3\n * @async\n * @param {string|Buffer|URL} pathToFile\n * @returns {Promise<string|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function hashCrc32(pathToFile) {\n  return crc32((await readFile(pathToFile)).toString(\"binary\")).toString(16);\n}\n","import { hash } from \"./hash.js\";\n\n/**\n * @name hashMd5\n * @description MD5.\n * @since 0.2.3\n * @async\n * @param {string|Buffer|URL} pathToFile\n * @returns {Promise<string|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function hashMd5(pathToFile) {\n  return hash(pathToFile, \"md5\");\n}\n","import { hash } from \"./hash.js\";\n\n/**\n * @name hashSha1\n * @description SHA-1.\n * @since 0.2.3\n * @async\n * @param {string|Buffer|URL} pathToFile\n * @returns {Promise<string|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function hashSha1(pathToFile) {\n  return hash(pathToFile, \"sha1\");\n}\n","import { hash } from \"./hash.js\";\n\n/**\n * @name hashSha256\n * @description SHA-256.\n * @since 0.2.3\n * @async\n * @param {string|Buffer|URL} pathToFile\n * @returns {Promise<string|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function hashSha256(pathToFile) {\n  return hash(pathToFile, \"sha256\");\n}\n","import { hash } from \"./hash.js\";\n\n/**\n * @name hashSha512\n * @description SHA-512.\n * @since 0.2.6\n * @async\n * @param {string|Buffer|URL} pathToFile\n * @returns {Promise<string|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function hashSha512(pathToFile) {\n  return hash(pathToFile, \"sha512\");\n}\n","import { stat } from \"node:fs/promises\";\n\n/**\n * @name size\n * @description File size in bytes.\n * @since 0.2.3\n * @async\n * @param {string|Buffer|URL} pathToFile\n * @param {boolean=} [asString=false]\n * @returns {Promise<number|string|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function size(pathToFile, asString = false) {\n  const fileStats = await stat(pathToFile);\n  if (!asString) {\n    return fileStats.size;\n  }\n  return fileStats.size.toLocaleString(\"en\").replace(/,/g, \"_\");\n}\n","import { constants } from \"node:fs\";\n\nimport { accessWrapper } from \"../access/wrapper.js\";\n\n/**\n * @name fileIsExecutable\n * @description File can be executed by the calling process\n * @since 0.0.5\n * @async\n * @param {string|Buffer|URL} pathToFile\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function fileIsExecutable(pathToFile) {\n  return accessWrapper(constants.X_OK, pathToFile);\n}\n","import { constants } from \"node:fs\";\n\nimport { accessWrapper } from \"../access/wrapper.js\";\n\n/**\n * @name fileIsReadable\n * @description File is visible to the calling process\n * @since 0.0.1\n * @async\n * @param {string|Buffer|URL} pathToFile\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function fileIsReadable(pathToFile) {\n  return accessWrapper(constants.R_OK, pathToFile);\n}\n","import { constants } from \"node:fs\";\n\nimport { accessWrapper } from \"../access/wrapper.js\";\n\n/**\n * @name fileIsVisible\n * @description File is visible to the calling process\n * @since 0.0.5\n * @async\n * @param {string|Buffer|URL} pathToFile\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function fileIsVisible(pathToFile) {\n  return accessWrapper(constants.F_OK, pathToFile);\n}\n","import { constants } from \"node:fs\";\n\nimport { accessWrapper } from \"../access/wrapper.js\";\n\n/**\n * @name fileIsWritable\n * @description File can be written by the calling process\n * @since 0.0.1\n * @async\n * @param {string|Buffer|URL} pathToFile\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function fileIsWritable(pathToFile) {\n  return accessWrapper(constants.W_OK, pathToFile);\n}\n","import { truncate } from \"node:fs/promises\";\n\n/**\n * @name fileTruncate\n * @description Truncate a file to a specified length\n * @since 0.0.6\n * @async\n * @param {string|Buffer|URL} pathToFile\n * @param {number=} length\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function fileTruncate(pathToFile, length = 0) {\n  try {\n    await truncate(pathToFile, length);\n    return true;\n  } catch (error) {\n    return error;\n  }\n}\n","import { join, normalize } from \"node:path\";\n\n/**\n * @name pathFrom\n * @description Join all arguments together and normalize the resulting path.\n * @since 0.1.3\n * @param {string|Array.<string>} paths\n * @param {...string} morePaths\n * @returns {string}\n */\nexport function pathFrom(paths, ...morePaths) {\n  let routes;\n  if (Array.isArray(paths)) {\n    routes = paths.map((path) => path.toString());\n  } else {\n    routes = [paths.toString()];\n  }\n  if (morePaths.length) {\n    routes = routes.concat(morePaths.map((path) => path.toString()));\n  }\n  return normalize(join(...routes));\n}\n","import { getStatus } from \"../status/getStatus.js\";\nimport { listContents } from \"./contents.js\";\nimport { pathFrom } from \"../path/pathFrom.js\";\n\n/**\n * @name listDirectories\n * @description Lists directories in path\n * @since 0.1.32\n * @async\n * @param {string|Buffer|URL} pathToDir\n * @returns {Promise<Array.<string>|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function listDirectories(pathToDir) {\n  const contents = await listContents(pathToDir);\n  if (!Array.isArray(contents)) {\n    return contents;\n  }\n  const directories = await Promise.all(\n    contents.map(async (content) => {\n      const contentPath = pathFrom(pathToDir, content);\n      const [status, error] = await getStatus(contentPath);\n      if (error) {\n        return undefined;\n      }\n      if (!status.isDirectory()) {\n        return undefined;\n      }\n      return content;\n    }),\n  );\n  return directories.filter((content) => content);\n}\n","import { getStatus } from \"../status/getStatus.js\";\nimport { listContents } from \"./contents.js\";\nimport { pathFrom } from \"../path/pathFrom.js\";\n\n/**\n * @name listFiles\n * @description Lists files in path\n * @since 0.1.32\n * @async\n * @param {string|Buffer|URL} pathToDir\n * @returns {Promise<Array.<string>|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function listFiles(pathToDir) {\n  const contents = await listContents(pathToDir);\n  if (!Array.isArray(contents)) {\n    return contents;\n  }\n  const files = await Promise.all(\n    contents.map(async (content) => {\n      const contentPath = pathFrom(pathToDir, content);\n      const [status, error] = await getStatus(contentPath);\n      if (error) {\n        return undefined;\n      }\n      if (status.isDirectory()) {\n        return undefined;\n      }\n      return content;\n    }),\n  );\n  return files.filter((content) => content);\n}\n","import { rename } from \"node:fs/promises\";\n\n/**\n * @name move\n * @description Change the name or location of a file or directory.\n * @since 0.1.29\n * @param {string} pathFrom\n * @param {string} pathTo\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function move(pathFrom, pathTo) {\n  try {\n    await rename(pathFrom, pathTo);\n    return true;\n  } catch (error) {\n    return error;\n  }\n}\n","import os from \"os\";\n\nconst HOME_DIRECTORY = os.homedir();\n\n/**\n * @description deConvert a tilde path to an absolute path: ~/projects → /Users/anon/projects\n * @param {string} pathWithTilde\n * @returns {string}\n */\nexport function absolutePath(pathWithTilde) {\n  if (HOME_DIRECTORY) {\n    return String(pathWithTilde).replace(/^~(?=$|\\/|\\\\)/, HOME_DIRECTORY);\n  }\n  return String(pathWithTilde);\n}\n","import { resolve } from \"node:path\";\n\nimport { absolutePath } from \"./absolutePath.js\";\n\n/**\n * @name absolutePathFrom\n * @description Join all arguments together and normalize the resulting path.\n * Creates absolute path from right to left until an absolute path is constructed.\n * @since 0.1.5\n * @param {string|Array.<string>} paths\n * @param {...string} morePaths\n * @returns {string}\n */\nexport function absolutePathFrom(paths, ...morePaths) {\n  let routes;\n  if (Array.isArray(paths)) {\n    routes = paths.map((path) => path.toString());\n  } else {\n    routes = [paths.toString()];\n  }\n  if (morePaths.length) {\n    routes = routes.concat(morePaths.map((path) => path.toString()));\n  }\n  return absolutePath(resolve(...routes));\n}\n","import { extname } from \"node:path\";\n\n/**\n * @name fileExtension\n * @description Get file extension.\n * @since 0.1.1\n * @param {string} path\n * @returns {string}\n */\nexport function fileExtension(path) {\n  return extname(path).substring(1);\n}\n","import { parse } from \"node:path\";\n\n/**\n * @name fileName\n * @description Return the file name without extension.\n * @since 0.1.1\n * @param {string} path\n * @returns {string}\n */\nexport function fileName(path) {\n  return parse(path).name;\n}\n","import { basename } from \"node:path\";\n\n/**\n * @name fileNameExt\n * @description Return the last portion of a path.\n * @since 0.1.1\n * @param {string} path\n * @returns {string}\n */\nexport function fileNameExt(path) {\n  return basename(path);\n}\n","import { dirname } from \"node:path\";\n\n/**\n * @name filePath\n * @description Return the directory name of a path.\n * @since 0.1.1\n * @param {string} path\n * @returns {string}\n */\nexport function filePath(path) {\n  return dirname(path);\n}\n","import { readFile } from \"node:fs/promises\";\n\n/**\n * @name readFileToBase64\n * @description Asynchronously reads the entire contents of a file into string.\n * @since 0.1.21\n * @async\n * @param {string|Buffer|URL} pathLike\n * @returns {Promise<string|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function readFileToBase64(pathLike) {\n  try {\n    const result = await readFile(pathLike, \"base64\");\n    return result.toString();\n  } catch (error) {\n    return error;\n  }\n}\n","import { readFile } from \"node:fs/promises\";\n\n/**\n * @name readFileToBuffer\n * @description Asynchronously reads the entire contents of a file into buffer.\n * @since 0.1.19\n * @async\n * @param {string|Buffer|URL} pathLike\n * @returns {Promise<Buffer|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function readFileToBuffer(pathLike) {\n  try {\n    const result = await readFile(pathLike, \"binary\");\n    return Buffer.from(result);\n  } catch (error) {\n    return error;\n  }\n}\n","import { readFile } from \"node:fs/promises\";\n\nimport { absolutePath } from \"../path/absolutePath.js\";\n\n/**\n * @name readFileToString\n * @description Asynchronously reads the entire contents of a file into string.\n * @since 0.1.7\n * @async\n * @param {string|Buffer|URL} pathLike\n * @returns {Promise<string|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function readFileToString(pathLike) {\n  try {\n    const result = await readFile(absolutePath(pathLike), \"utf8\");\n    return result.toString();\n  } catch (error) {\n    return error;\n  }\n}\n","import fs from \"fs\";\nimport assert from \"node:assert\";\nimport { join } from \"node:path\";\n\nconst IS_WINDOWS = process.platform === \"win32\";\n\n/**\n * @param {object} options\n */\nfunction defaults(options) {\n  const methods = [\"unlink\", \"chmod\", \"stat\", \"lstat\", \"rmdir\", \"readdir\"];\n  methods.forEach((method) => {\n    options[method] = options[method] || fs[method];\n  });\n  options.maxBusyTries = options.maxBusyTries || 3;\n}\n\n/**\n * @param {string} pathLike\n * @param {Function|object=} options\n * @param {Function=} callback\n */\nfunction rimraf(pathLike, options, callback) {\n  let busyTries = 0;\n  let localCallback = callback;\n  let localOptions = options;\n  if (typeof localOptions === \"function\") {\n    localCallback = localOptions;\n    localOptions = {};\n  }\n  assert(pathLike, \"remove(): missing path\");\n  assert.strictEqual(typeof pathLike, \"string\", \"remove(): path should be a string\");\n  assert.strictEqual(typeof localCallback, \"function\", \"remove(): callback function required\");\n  assert(localOptions, \"remove(): invalid options argument provided\");\n  assert.strictEqual(typeof localOptions, \"object\", \"remove(): options should be object\");\n  defaults(localOptions);\n  rimraf_(pathLike, localOptions, function callbackRimraf(error) {\n    if (error) {\n      if (\n        (error.code === \"EBUSY\" || error.code === \"ENOTEMPTY\" || error.code === \"EPERM\") &&\n        busyTries < localOptions.maxBusyTries\n      ) {\n        busyTries++;\n        const time = busyTries * 100;\n        setTimeout(() => rimraf_(pathLike, localOptions, callbackRimraf), time);\n        return;\n      }\n      if (error.code === \"ENOENT\") {\n        localCallback(null);\n        return;\n      }\n    }\n    localCallback(error);\n  });\n}\n\n/**\n * @param {string} pathLike\n * @param {Function|object=} options\n * @param {Function=} callback\n */\nfunction rimraf_(pathLike, options, callback) {\n  assert(pathLike);\n  assert(options);\n  assert(typeof callback === \"function\");\n  options.lstat(pathLike, (error, stats) => {\n    if (error && error.code === \"ENOENT\") {\n      return callback(null);\n    }\n    if (error && error.code === \"EPERM\" && IS_WINDOWS) {\n      return fixWinEPERM(pathLike, options, error, callback);\n    }\n    if (stats && stats.isDirectory()) {\n      return rmdir(pathLike, options, error, callback);\n    }\n    options.unlink(pathLike, (error) => {\n      if (error) {\n        if (error.code === \"ENOENT\") {\n          return callback(null);\n        }\n        if (error.code === \"EPERM\") {\n          if (IS_WINDOWS) {\n            return fixWinEPERM(pathLike, options, error, callback);\n          } else {\n            return rmdir(pathLike, options, error, callback);\n          }\n        }\n        if (error.code === \"EISDIR\") {\n          return rmdir(pathLike, options, error, callback);\n        }\n      }\n      return callback(error);\n    });\n  });\n}\n\n/**\n * @param {string} pathLike\n * @param {Function|object=} options\n * @param {Error|null} error\n * @param {Function=} callback\n * @returns {null}\n */\nfunction fixWinEPERM(pathLike, options, error, callback) {\n  assert(pathLike);\n  assert(options);\n  assert(typeof callback === \"function\");\n  if (error) {\n    assert(error instanceof Error);\n  }\n  options.chmod(pathLike, 0o666, (errorChMod) => {\n    if (errorChMod) {\n      if (errorChMod.code === \"ENOENT\") {\n        callback(null);\n      } else {\n        callback(error);\n      }\n    } else {\n      options.stat(pathLike, (errorStat, stats) => {\n        if (errorStat) {\n          if (errorStat.code === \"ENOENT\") {\n            callback(null);\n          } else {\n            callback(error);\n          }\n        } else if (stats.isDirectory()) {\n          rmdir(pathLike, options, error, callback);\n        } else {\n          options.unlink(pathLike, callback);\n        }\n      });\n    }\n  });\n  return null;\n}\n\n/**\n * @param {string} pathLike\n * @param {Function|object=} options\n * @param {Error|null} originalError\n * @param {Function=} callback\n * @returns {null}\n */\nfunction rmdir(pathLike, options, originalError, callback) {\n  assert(pathLike);\n  assert(options);\n  if (originalError) {\n    assert(originalError instanceof Error);\n  }\n  assert(typeof callback === \"function\");\n  options.rmdir(pathLike, (error) => {\n    if (error && (error.code === \"ENOTEMPTY\" || error.code === \"EEXIST\" || error.code === \"EPERM\")) {\n      removeSubPath(pathLike, options, callback);\n    } else if (error && error.code === \"ENOTDIR\") {\n      callback(originalError);\n    } else {\n      callback(error);\n    }\n  });\n  return null;\n}\n\n/**\n * @param {string} pathLike\n * @param {Function|object=} options\n * @param {Function=} callback\n */\nfunction removeSubPath(pathLike, options, callback) {\n  assert(pathLike);\n  assert(options);\n  assert(typeof callback === \"function\");\n  options.readdir(pathLike, (error, files) => {\n    if (error) {\n      return callback(error);\n    }\n    let count = files.length;\n    let errState;\n    if (count === 0) {\n      return options.rmdir(pathLike, callback);\n    }\n    files.forEach((filePath) => {\n      rimraf(join(pathLike, filePath), options, (error) => {\n        if (errState) {\n          return;\n        }\n        if (error) {\n          callback((errState = error));\n          return;\n        }\n        --count;\n        if (count === 0) {\n          options.rmdir(pathLike, callback);\n        }\n      });\n    });\n  });\n}\n\n/**\n * @name remove\n * @description Removes a file or directory.\n * @since 0.1.1\n * @async\n * @param {string} pathLike\n * @returns {Promise<undefined|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function remove(pathLike) {\n  return new Promise((resolve) => {\n    rimraf(pathLike, {}, (error) => {\n      if (error) {\n        resolve(error);\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n","import { remove } from \"./remove.js\";\n\n/**\n * @name removeNonBlocking\n * @description Non-blocking remove of a file or directory.\n * @since 0.1.18\n * @param {string|Buffer|URL} pathLike\n * @returns {void}\n */\nexport function removeNonBlocking(pathLike) {\n  remove(pathLike)\n    .then(() => undefined)\n    .catch(() => undefined); // don't put it into next tick\n}\n","import { rm } from \"node:fs/promises\";\n\n/**\n * @name removeSilent\n * @description Removes files and directories (modeled on the standard POSIX rm utility).\n * @summary Minimum Node version 14.14.0\n * @since 0.1.36\n * @async\n * @param {string|Buffer|URL} pathLike\n * @param {object=} options\n * @returns {Promise<void>}\n */\nexport async function removeSilent(pathLike, options) {\n  try {\n    await rm(pathLike, {\n      force: true,\n      recursive: true,\n      ...options,\n    });\n  } catch (__error) {\n    //\n  }\n}\n","import { lstat } from \"node:fs/promises\";\n\n/**\n * @name getLinkStatus\n * @description Get file status unless `path` refers to a symbolic link, in which case the link itself is stat-ed, not the file that it refers to.\n * @url http://man7.org/linux/man-pages/man2/lstat.2.html\n * @since 1.1.0\n * @async\n * @param {string|Buffer|URL} path\n * @returns {Promise<Array.<(object|undefined|Error|{name: string, message: string, stack?: string})>>}\n */\nexport async function getLinkStatus(path) {\n  try {\n    return [await lstat(path)];\n  } catch (error) {\n    return [undefined, error];\n  }\n}\n","import { getStatus } from \"./getStatus.js\";\n\n/**\n * @name isDirExists\n * @description Get directory status.\n * @since 0.0.11\n * @async\n * @param {string|Buffer|URL} path\n * @returns {Promise<boolean>}\n */\nexport async function isDirExists(path) {\n  const [status, error] = await getStatus(path);\n  if (error) {\n    return false;\n  }\n  return status.isDirectory();\n}\n","import { getStatus } from \"./getStatus.js\";\n\n/**\n * @name isFileExists\n * @description Get file status.\n * @since 0.0.11\n * @async\n * @param {string|Buffer|URL} path\n * @returns {Promise<boolean>}\n */\nexport async function isFileExists(path) {\n  const [status, error] = await getStatus(path);\n  if (error) {\n    return false;\n  }\n  return status.isFile();\n}\n","import { getStatus } from \"./getStatus.js\";\n\n/**\n * @name isPathExists\n * @description Get path status.\n * @since 0.0.11\n * @async\n * @param {string|Buffer|URL} path\n * @returns {Promise<boolean>}\n */\nexport async function isPathExists(path) {\n  const [status] = await getStatus(path);\n  return Boolean(status);\n}\n","import { createFile } from \"../create/createFile.js\";\nimport { isFileExists } from \"../status/isFileExists.js\";\nimport { readFileToString } from \"../read/readFileToString.js\";\nimport { writeFile } from \"./writeFile.js\";\n\n/**\n * @name writeFileTail\n * @description Asynchronously writes data to the end of a file.\n * @since 1.0.1\n * @async\n * @param {string|Buffer|URL} filePath\n * @param {string} data\n * @param {*|null|string=} options\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function writeFileTail(filePath, data, options) {\n  const isFileExist = await isFileExists(filePath);\n  if (isFileExist === false) {\n    const isFileCreatedOrError = await createFile(filePath);\n    if (isFileCreatedOrError !== true) {\n      return isFileCreatedOrError;\n    }\n  }\n  const contentOrError = await readFileToString(filePath);\n  if (contentOrError instanceof Error) {\n    return contentOrError;\n  }\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      writeFile(filePath, `${String(contentOrError)}${String(data)}`, options)\n        .then(() => {\n          resolve(true);\n        })\n        .catch((error) => {\n          reject(error);\n        });\n    }, 1);\n  });\n}\n","import { writeFile } from \"./writeFile.js\";\n\n/**\n * @name objectKeys\n * @param {object} object\n * @returns {Array.<string>}\n */\nfunction objectKeys(object) {\n  return Object.keys(object).sort((alpha, beta) => alpha.localeCompare(beta));\n}\n\n/**\n * name isObjectLike\n * @param {*} value\n * @returns {boolean}\n */\nfunction isObjectLike(value) {\n  return value !== null && typeof value === \"object\" && !Array.isArray(value);\n}\n\n/**\n * @name collectionSortKeys\n * @param {*} value\n * @param {boolean=} [isDeep=true]\n * @returns {*}\n */\nfunction collectionSortKeys(value, isDeep = true) {\n  if (!isObjectLike(value)) {\n    if (Array.isArray(value)) {\n      return value.map((arrayValue) => collectionSortKeys(arrayValue, isDeep));\n    }\n    return value;\n  }\n  const keys = objectKeys(value);\n  if (!keys.length) {\n    return value;\n  }\n  return keys.reduce((sorted, key) => {\n    if (isDeep && isObjectLike(value[key])) {\n      sorted[key] = collectionSortKeys(value[key], isDeep);\n    } else if (isDeep && Array.isArray(value[key])) {\n      sorted[key] = collectionSortKeys(value[key], isDeep);\n    } else {\n      sorted[key] = value[key];\n    }\n    return sorted;\n  }, {});\n}\n\n/**\n * @name writeJSON\n * @description Asynchronously writes data to a file, replacing the file if it already exists.\n * @since 0.1.25\n * @async\n * @param {string|Buffer|URL} filePath\n * @param {*} data\n * @param {*|null|string=} options\n * @param {{sort: boolean, space: number|string}=} configuration\n * @returns {Promise<boolean|Error|{name: string, message: string, stack: string}>}\n */\nexport async function writeJSON(filePath, data, options, configuration) {\n  let json;\n  let stringify = data;\n  try {\n    if (configuration) {\n      if (configuration.sort) {\n        if (isObjectLike(data)) {\n          stringify = collectionSortKeys(JSON.parse(JSON.stringify(data)));\n        } else if (Array.isArray(data)) {\n          stringify = JSON.parse(JSON.stringify(data));\n        } else {\n          stringify = data;\n        }\n      }\n      if (configuration.space) {\n        json = JSON.stringify(stringify, null, configuration.space);\n      }\n    } else {\n      json = JSON.stringify(stringify);\n    }\n  } catch (error) {\n    return error;\n  }\n  return writeFile(filePath, json, options);\n}\n","import { absolutePathFrom } from \"./path/absolutePathFrom.js\";\n\nimport { createDirectory } from \"./create/createDirectory.js\";\nimport { createFile } from \"./create/createFile.js\";\n\nimport { dirIsExecutable } from \"./dir/dirIsExecutable.js\";\nimport { dirIsReadable } from \"./dir/dirIsReadable.js\";\nimport { dirIsVisible } from \"./dir/dirIsVisible.js\";\nimport { dirIsWritable } from \"./dir/dirIsWritable.js\";\nimport { dirIsEmpty } from \"./dir/dirIsEmpty.js\";\n\nimport { fileExtension } from \"./path/fileExtension.js\";\nimport { fileIsExecutable } from \"./file/fileIsExecutable.js\";\nimport { fileIsReadable } from \"./file/fileIsReadable.js\";\nimport { fileIsVisible } from \"./file/fileIsVisible.js\";\nimport { fileIsWritable } from \"./file/fileIsWritable.js\";\nimport { fileName } from \"./path/fileName.js\";\nimport { fileNameExt } from \"./path/fileNameExt.js\";\nimport { filePath } from \"./path/filePath.js\";\nimport { fileTruncate } from \"./file/fileTruncate.js\";\n\nimport { listContents } from \"./list/contents.js\";\nimport { listDirectories } from \"./list/directories.js\";\nimport { listFiles } from \"./list/files.js\";\n\nimport { getLinkStatus } from \"./status/getLinkStatus.js\";\nimport { getStatus } from \"./status/getStatus.js\";\n\nimport { isDirExists } from \"./status/isDirExists.js\";\nimport { isFileExists } from \"./status/isFileExists.js\";\nimport { isPathExists } from \"./status/isPathExists.js\";\n\nimport { move } from \"./move/move.js\";\n\nimport { pathFrom } from \"./path/pathFrom.js\";\n\nimport { readFileToBase64 } from \"./read/readFileToBase64.js\";\nimport { readFileToBuffer } from \"./read/readFileToBuffer.js\";\nimport { readFileToString } from \"./read/readFileToString.js\";\nimport { remove } from \"./remove/remove.js\";\nimport { removeNonBlocking } from \"./remove/removeNonBlocking.js\";\nimport { removeSilent } from \"./remove/removeSilent.js\";\n\nimport { writeFile } from \"./write/writeFile.js\";\nimport { writeFileTail } from \"./write/writeFileTail.js\";\nimport { writeJSON } from \"./write/writeJSON.js\";\n\nimport { hash } from \"./info/hash.js\";\nimport { hashCrc32 } from \"./info/hash-crc32.js\";\nimport { hashMd5 } from \"./info/hash-md5.js\";\nimport { hashSha1 } from \"./info/hash-sha1.js\";\nimport { hashSha256 } from \"./info/hash-sha256.js\";\nimport { hashSha512 } from \"./info/hash-sha512.js\";\n\nimport { size } from \"./info/size.js\";\n\nexport class HileSystemLocal {\n  /**\n   * @name absolutePathFrom\n   * @description Join all arguments together and normalize the resulting path.\n   * reates absolute path from right to left until an absolute path is constructed.\n   * @since 0.1.5\n   * @public\n   * @param {string|Array.<string>} paths\n   * @param {...string} morePaths\n   * @returns {string}\n   */\n  absolutePathFrom = absolutePathFrom;\n  /**\n   * @name createDirectory\n   * @description Asynchronous create a directory.\n   * @since 0.0.10\n   * @async\n   * @public\n   * @param {string|Buffer|URL} dirPath\n   * @param {number|string=} mode\n   * @param {boolean=} recursive\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  createDirectory = createDirectory;\n  /**\n   * @name createFile\n   * @description Asynchronous create a file.\n   * @since 0.0.11\n   * @async\n   * @public\n   * @param {string|Buffer|URL} pathLike\n   * @param {number|string=} mode\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  createFile = createFile;\n  /**\n   * @name dirIsExecutable\n   * @description Directory can be executed by the calling process\n   * @since 0.0.5\n   * @async\n   * @public\n   * @param {string} pathToDir\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  dirIsExecutable = dirIsExecutable;\n  /**\n   * @name dirIsReadable\n   * @description Directory is visible to the calling process\n   * @since 0.0.1\n   * @async\n   * @public\n   * @param {string} pathToDir\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  dirIsReadable = dirIsReadable;\n  /**\n   * @name dirIsVisible\n   * @description Directory is visible to the calling process\n   * @since 0.0.5\n   * @async\n   * @public\n   * @param {string} pathToDir\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  dirIsVisible = dirIsVisible;\n  /**\n   * @name dirIsWritable\n   * @description Directory can be written by the calling process\n   * @since 0.0.1\n   * @async\n   * @public\n   * @param {string} pathToDir\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  dirIsWritable = dirIsWritable;\n  /**\n   * @name dirIsEmpty\n   * @description Check if a directory is empty\n   * @since 0.1.33\n   * @async\n   * @public\n   * @param {string|Buffer|URL} pathToDir\n   * @param {boolean=} excludeSystemFiles\n   * @returns {Promise<boolean>}\n   * @throws {Error} If path is not a dir or is not readable.\n   */\n  dirIsEmpty = dirIsEmpty;\n  /**\n   * @name getLinkStatus\n   * @description Get file status unless `path` refers to a symbolic link, in which case the link itself is stat-ed, not the file that it refers to.\n   * @url http://man7.org/linux/man-pages/man2/lstat.2.html\n   * @since 1.1.0\n   * @async\n   * @param {string|Buffer|URL} path\n   * @returns {Promise<Array.<(object|undefined|Error|{name: string, message: string, stack?: string})>>}\n   */\n  getLinkStatus = getLinkStatus;\n  /**\n   * @name getStatus\n   * @description Get file status.\n   * @since 0.0.11\n   * @async\n   * @public\n   * @param {string|Buffer|URL} path\n   * @returns {Promise<Array.<(object|undefined|Error|{name: string, message: string, stack?: string})>>}\n   */\n  getStatus = getStatus;\n  /**\n   * @name isDirExists\n   * @description Get directory status.\n   * @since 0.0.11\n   * @async\n   * @public\n   * @param {string|Buffer|URL} path\n   * @returns {Promise<boolean>}\n   */\n  isDirExists = isDirExists;\n  /**\n   * @name isFileExists\n   * @description Get file status.\n   * @since 0.0.11\n   * @async\n   * @public\n   * @param {string|Buffer|URL} path\n   * @returns {Promise<boolean>}\n   */\n  isFileExists = isFileExists;\n  /**\n   * @name isPathExists\n   * @description Get path status.\n   * @since 0.0.11\n   * @async\n   * @public\n   * @param {string|Buffer|URL} path\n   * @returns {Promise<boolean>}\n   */\n  isPathExists = isPathExists;\n  /**\n   * @name fileExtension\n   * @description Get file extension.\n   * @since 0.1.1\n   * @public\n   * @param {string} path\n   * @returns {string}\n   */\n  fileExtension = fileExtension;\n  /**\n   * @name fileName\n   * @description Return the file name without extension.\n   * @since 0.1.1\n   * @public\n   * @param {string} path\n   * @returns {string}\n   */\n  fileName = fileName;\n  /**\n   * @name fileNameExt\n   * @description Return the last portion of a path.\n   * @since 0.1.1\n   * @public\n   * @param {string} path\n   * @returns {string}\n   */\n  fileNameExt = fileNameExt;\n  /**\n   * @name filePath\n   * @description Return the directory name of a path.\n   * @since 0.1.1\n   * @public\n   * @param {string} path\n   * @returns {string}\n   */\n  filePath = filePath;\n  /**\n   * @name fileIsExecutable\n   * @description File can be executed by the calling process\n   * @since 0.0.5\n   * @async\n   * @public\n   * @param {string|Buffer|URL} pathToFile\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  fileIsExecutable = fileIsExecutable;\n  /**\n   * @name fileIsReadable\n   * @description File is visible to the calling process\n   * @since 0.0.1\n   * @async\n   * @public\n   * @param {string|Buffer|URL} pathToFile\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  fileIsReadable = fileIsReadable;\n  /**\n   * @name fileIsVisible\n   * @description File is visible to the calling process\n   * @since 0.0.5\n   * @async\n   * @public\n   * @param {string|Buffer|URL} pathToFile\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  fileIsVisible = fileIsVisible;\n  /**\n   * @name fileIsWritable\n   * @description File can be written by the calling process\n   * @since 0.0.1\n   * @async\n   * @public\n   * @param {string|Buffer|URL} pathToFile\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  fileIsWritable = fileIsWritable;\n  /**\n   * @name fileTruncate\n   * @description Truncate a file to a specified length\n   * @since 0.0.6\n   * @async\n   * @public\n   * @param {string|Buffer|URL} pathToFile\n   * @param {number=} length\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  fileTruncate = fileTruncate;\n  /**\n   * @name hash\n   * @description Calculate hash.\n   * @since 0.2.3\n   * @async\n   * @public\n   * @param {string|Buffer|URL} pathToFile\n   * @param {string} algorithm\n   * @returns {Promise<string|Error|{name: string, message: string, stack?: string}>}\n   * @throws {TypeError} If algorithm is not supported.\n   */\n  hash = hash;\n  /**\n   * @name hashCrc32\n   * @description CRC32.\n   * @since 0.2.3\n   * @async\n   * @public\n   * @param {string|Buffer|URL} pathToFile\n   * @returns {Promise<string|Error|{name: string, message: string, stack?: string}>}\n   */\n  hashCrc32 = hashCrc32;\n  /**\n   * @name hashMd5\n   * @description MD5.\n   * @since 0.2.3\n   * @async\n   * @public\n   * @param {string|Buffer|URL} pathToFile\n   * @returns {Promise<string|Error|{name: string, message: string, stack?: string}>}\n   */\n  hashMd5 = hashMd5;\n  /**\n   * @name hashSha1\n   * @description SHA-1.\n   * @since 0.2.3\n   * @async\n   * @public\n   * @param {string|Buffer|URL} pathToFile\n   * @returns {Promise<string|Error|{name: string, message: string, stack?: string}>}\n   */\n  hashSha1 = hashSha1;\n  /**\n   * @name hashSha256\n   * @description SHA-256.\n   * @since 0.2.3\n   * @async\n   * @public\n   * @param {string|Buffer|URL} pathToFile\n   * @returns {Promise<string|Error|{name: string, message: string, stack?: string}>}\n   */\n  hashSha256 = hashSha256;\n  /**\n   * @name hashSha512\n   * @description SHA-512.\n   * @since 0.2.6\n   * @async\n   * @public\n   * @param {string|Buffer|URL} pathToFile\n   * @returns {Promise<string|Error|{name: string, message: string, stack?: string}>}\n   */\n  hashSha512 = hashSha512;\n  /**\n   * @name listContents\n   * @description Lists files and directories in path\n   * @since 0.1.32\n   * @async\n   * @param {string|Buffer|URL} pathToDir\n   * @returns {Promise<Array.<string>|Error|{name: string, message: string, stack?: string}>}\n   */\n  listContents = listContents;\n  /**\n   * @name listDirectories\n   * @description Lists directories in path\n   * @since 0.1.32\n   * @async\n   * @param {string|Buffer|URL} pathToDir\n   * @returns {Promise<Array.<string>|Error|{name: string, message: string, stack?: string}>}\n   */\n  listDirectories = listDirectories;\n  /**\n   * @name listFiles\n   * @description Lists files in path\n   * @since 0.1.32\n   * @async\n   * @param {string|Buffer|URL} pathToDir\n   * @returns {Promise<Array.<string>|Error|{name: string, message: string, stack?: string}>}\n   */\n  listFiles = listFiles;\n  /**\n   * @name move\n   * @description Change the name or location of a file or directory.\n   * @since 0.1.29\n   * @public\n   * @param {string} pathFrom\n   * @param {string} pathTo\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  move = move;\n  /**\n   * @name pathFrom\n   * @description Join all arguments together and normalize the resulting path.\n   * @since 0.1.3\n   * @public\n   * @param {string|Array.<string>} paths\n   * @param {...string} morePaths\n   * @returns {string}\n   */\n  pathFrom = pathFrom;\n  /**\n   * @name readFileToBase64\n   * @description Asynchronously reads the entire contents of a file into string.\n   * @since 0.1.21\n   * @async\n   * @param {string|Buffer|URL} pathLike\n   * @returns {Promise<string|Error|{name: string, message: string, stack?: string}>}\n   */\n  readFileToBase64 = readFileToBase64;\n  /**\n   * @name readFileToBuffer\n   * @description Asynchronously reads the entire contents of a file into buffer.\n   * @since 0.1.19\n   * @async\n   * @param {string|Buffer|URL} pathLike\n   * @returns {Promise<Buffer|Error|{name: string, message: string, stack?: string}>}\n   */\n  readFileToBuffer = readFileToBuffer;\n  /**\n   * @name readFileToString\n   * @description Asynchronously reads the entire contents of a file into string.\n   * @since 0.1.7\n   * @async\n   * @param {string|Buffer|URL} pathLike\n   * @returns {Promise<string|Error|{name: string, message: string, stack?: string}>}\n   */\n  readFileToString = readFileToString;\n  /**\n   * @name remove\n   * @description Removes a file or directory.\n   * @since 0.1.1\n   * @async\n   * @public\n   * @param {string} pathLike\n   * @returns {Promise<undefined|Error|{name: string, message: string, stack?: string}>}\n   */\n  remove = remove;\n  /**\n   * @name removeNonBlocking\n   * @description Non-blocking remove of a file or directory.\n   * @since 0.1.18\n   * @public\n   * @param {string} pathLike\n   * @returns {void}\n   */\n  removeNonBlocking = removeNonBlocking;\n  /**\n   * @name removeSilent\n   * @description Removes files and directories (modeled on the standard POSIX rm utility).\n   * @summary Minimum Node version 14.14.0\n   * @since 0.1.36\n   * @async\n   * @param {string|Buffer|URL} pathLike\n   * @param {object=} options\n   * @returns {Promise<void>}\n   */\n  removeSilent = removeSilent;\n  /**\n   * @name size\n   * @description File size in bytes.\n   * @since 0.2.3\n   * @async\n   * @public\n   * @param {string|Buffer|URL} pathToFile\n   * @param {boolean=} [asString=false]\n   * @returns {Promise<number|string|Error|{name: string, message: string, stack?: string}>}\n   */\n  size = size;\n  /**\n   * @name writeFile\n   * @description Asynchronously writes data to a file, replacing the file if it already exists.\n   * @since 0.0.10\n   * @async\n   * @public\n   * @param {string|Buffer|URL} filePath\n   * @param {string} data\n   * @param {*|null|string=} options\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  writeFile = writeFile;\n  /**\n   * @name writeFileTail\n   * @description  Asynchronously writes data to the end of a file.\n   * @since 1.0.1\n   * @async\n   * @public\n   * @param {string|Buffer|URL} filePath\n   * @param {string} data\n   * @param {*|null|string=} options\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  writeFileTail = writeFileTail;\n  /**\n   * @name writeJSON\n   * @description Asynchronously writes data to a file, replacing the file if it already exists.\n   * @since 0.1.25\n   * @async\n   * @public\n   * @param {string|Buffer|URL} filePath\n   * @param {*} data\n   * @param {*|null|string=} options\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  writeJSON = writeJSON;\n}\n"],"names":["async","createDirectory","dirPath","mode","recursive","mkdir","error","getStatus","path","stat","undefined","writeFile","filePath","data","options","writeFileNative","createFile","pathLike","status","isFile","dirname","code","dirCreated","fileWritten","flag","isDirectory","readdir","accessWrapper","access","dirIsReadable","pathToDir","constants","R_OK","junkRegex","RegExp","join","isNotSystemJunk","fileName","isSystemJunk","test","listContents","ignoreJunk","contents","filter","EXCLUDE","dirIsEmpty","excludeSystemFiles","isReadableOrError","Error","message","errorExtractOptions","cause","values","errno","syscall","listOfDirsAndFiles","length","isEmptyContent","content","Set","forEach","dirOrFileName","nameToExclude","match","delete","size","dirIsExecutable","X_OK","dirIsVisible","F_OK","dirIsWritable","W_OK","hash","pathToFile","algorithm","getHashes","includes","TypeError","createHash","update","readFile","digest","hashCrc32","crc32","text","actual","chars","current","f","number","index","charCodeAt","toString","hashMd5","hashSha1","hashSha256","hashSha512","asString","fileStats","toLocaleString","replace","fileIsExecutable","fileIsReadable","fileIsVisible","fileIsWritable","fileTruncate","truncate","pathFrom","paths","morePaths","routes","Array","isArray","map","concat","normalize","listDirectories","Promise","all","contentPath","listFiles","move","pathTo","rename","HOME_DIRECTORY","os","homedir","absolutePath","pathWithTilde","String","absolutePathFrom","resolve","fileExtension","extname","substring","parse","name","fileNameExt","basename","readFileToBase64","readFileToBuffer","result","Buffer","from","readFileToString","IS_WINDOWS","process","platform","rimraf","callback","busyTries","localCallback","localOptions","assert","strictEqual","defaults","method","fs","maxBusyTries","rimraf_","callbackRimraf","setTimeout","lstat","stats","fixWinEPERM","rmdir","unlink","chmod","errorChMod","errorStat","originalError","removeSubPath","files","errState","count","remove","removeNonBlocking","then","catch","removeSilent","rm","force","__error","getLinkStatus","isDirExists","isFileExists","isPathExists","Boolean","writeFileTail","isFileCreatedOrError","contentOrError","reject","isObjectLike","value","collectionSortKeys","isDeep","arrayValue","keys","objectKeys","object","Object","sort","alpha","beta","localeCompare","reduce","sorted","key","writeJSON","configuration","json","stringify","JSON","space","HileSystemLocal","constructor","_defineProperty"],"mappings":"2WAYOA,eAAeC,gBAAgBC,EAASC,EAAO,OAAQC,GAAY,GACxE,IAEE,aADMC,QAAMH,EAAS,CAAEC,KAAAA,EAAMC,UAAAA,KACtB,EACP,MAAOE,GACP,OAAOA,GCPJN,eAAeO,UAAUC,GAC9B,IACE,MAAO,OAAOC,OAAKD,IACnB,MAAOF,GACP,MAAO,MAACI,EAAWJ,ICWhBN,eAAeW,UAAUC,EAAUC,EAAMC,GAC9C,IAEE,aADMC,YAAgBH,EAAUC,EAAMC,IAC/B,EACP,MAAOR,GACP,OAAOA,GCdJN,eAAegB,WAAWC,EAAUd,EAAO,QAChD,MAAOe,EAAQZ,SAAeC,UAAUU,GACxC,IAAKX,GAASY,EAAOC,SACnB,OAAO,EAET,MAAMjB,EAAUkB,UAAQH,GACxB,GAAIX,GACiB,WAAfA,EAAMe,KAAmB,CAC3B,MAAMC,QAAmBrB,gBAAgBC,EAASC,GAClD,IAAmB,IAAfmB,EACF,OAAOA,EAET,MAAMC,QAAoBZ,UAAUM,EAAU,GAAI,CAAEd,KAAAA,EAAMqB,KAAM,MAChE,OAAoB,IAAhBD,GACKA,EAKb,GAAIL,EAAOO,cACT,aAAad,UAAUM,EAAU,GAAI,CAAEd,KAAAA,EAAMqB,KAAM,MAEnD,IAEE,kBADME,UAAQxB,GAEd,MAAOI,GACP,OAAOA,GC/BNN,eAAe2B,cAAcxB,EAAMK,GACxC,IAEE,aADMoB,SAAOpB,EAAML,IACZ,EACP,MAAOG,GACP,OAAOA,GCJJN,eAAe6B,cAAcC,GAClC,OAAOH,cAAcI,YAAUC,KAAMF,GCXvC,MA2BaG,EAAY,IAAIC,OA3BV,CAEjB,oBACA,gBAGA,gBACA,mBACA,kBACA,YACA,UACA,8BACA,aACA,aAGA,KAGA,gBACA,kBACA,kBACA,UACA,mBACA,+BAG6CC,KAAK,MCpB7C,SAASC,gBAAgBC,GAC9B,OD4BK,SAASC,aAAaD,GAC3B,OAAOJ,EAAUM,KAAKF,GC7BdC,CAAaD,GCGhBrC,eAAewC,aAAaV,EAAWW,GAAa,GACzD,IACE,MAAMC,QAAiBhB,UAAQI,GAC/B,OAAIW,EACKC,EAASC,OAAOP,iBAElBM,EACP,MAAOpC,GACP,OAAOA,GCjBX,MAAMsC,EAAU,CAEd,WACA,gBACA,eACA,YACA,0BACA,cACA,kBACA,kBACA,WACA,mBAEA,UACA,sCACA,aACA,uBACA,kBAEA,gBAQA,cACA,YACA,wBACA,cACA,cACA,oBAIA,cAoCK5C,eAAe6C,WAAWf,EAAWgB,GAAqB,GAC/D,MAAMC,QAA0BlB,cAAcC,GAC9C,IAA0B,IAAtBiB,EACF,MAAM,IAAIC,MAAMD,EAAkBE,QC1E/B,SAASC,oBAAoB5C,GAClC,OAAMA,aAAiB0C,MAGnB,SAAU1C,GAAS,UAAWA,GAAS,SAAUA,GAAS,YAAaA,EAClE,CACL6C,MAAO,CACL9B,KAAMf,EAAMe,KACZ+B,OAAQ,CACNC,MAAO/C,EAAM+C,MACb7C,KAAMF,EAAME,KACZ8C,QAAShD,EAAMgD,gBAPvB,EAFS,CAAEH,MAAO7C,GDwE2B4C,CAAoBH,IAEjE,IAAIQ,QAA2Bf,aAAaV,GAC5C,GAAIyB,aAA8BP,MAChC,MAAMO,EAER,OAAkC,IAA9BA,EAAmBC,UAGlBV,GAtCP,SAASW,eAAeF,GACtB,MAAMG,EAAU,IAAIC,IAAIJ,GAYxB,OAXAA,EAAmBC,OAAS,EAC5BE,EAAQE,QAASC,IACf,IAAK,MAAMC,KAAiBlB,EACrBiB,IAGDA,IAAkBC,GAAiBD,EAAcE,MAAM7B,OAAO4B,MAChEJ,EAAQM,OAAOH,KAIG,IAAjBH,EAAQO,KA4BRR,CAAeF,GE/EjBvD,eAAekE,gBAAgBpC,GACpC,OAAOH,cAAcI,YAAUoC,KAAMrC,GCDhC9B,eAAeoE,aAAatC,GACjC,OAAOH,cAAcI,YAAUsC,KAAMvC,GCDhC9B,eAAesE,cAAcxC,GAClC,OAAOH,cAAcI,YAAUwC,KAAMzC,GCAhC9B,eAAewE,KAAKC,EAAYC,GACrC,IAAKC,cAAYC,SAASF,GACxB,MAAM,IAAIG,UAAW,qBAAoBH,wBAE3C,OAAOI,aAAWJ,GACfK,aAAaC,WAASP,IACtBQ,OAAO,OCSLjF,eAAekF,UAAUT,GAC9B,OA3BF,SAASU,MAAMC,GACb,IACIC,EADAC,EAAQ,GAEZ,IAAK,IAAIC,EAAU,EAAGA,EAAU,IAAKA,IAAW,CAC9CF,EAASE,EACT,IAAK,IAAIC,EAAI,EAAGA,EAAI,EAAGA,IACrBH,EAAS,EAAIA,EAAS,WAAcA,IAAW,EAAKA,IAAW,EAEjEC,EAAMC,GAAWF,EAEnB,IAAII,GAAU,EACVC,EAAQ,EACZ,KAAOA,EAAQN,EAAK5B,OAAQkC,IAC1BD,EAAUA,IAAW,EAAKH,EAAM,KAAOG,EAASL,EAAKO,WAAWD,KAElE,QAAS,EAAID,KAAY,EAYlBN,QAAaH,WAASP,IAAamB,SAAS,WAAWA,SAAS,ICnBlE5F,eAAe6F,QAAQpB,GAC5B,OAAOD,KAAKC,EAAY,OCDnBzE,eAAe8F,SAASrB,GAC7B,OAAOD,KAAKC,EAAY,QCDnBzE,eAAe+F,WAAWtB,GAC/B,OAAOD,KAAKC,EAAY,UCDnBzE,eAAegG,WAAWvB,GAC/B,OAAOD,KAAKC,EAAY,UCAnBzE,eAAeiE,KAAKQ,EAAYwB,GAAW,GAChD,MAAMC,QAAkBzF,OAAKgE,GAC7B,OAAKwB,EAGEC,EAAUjC,KAAKkC,eAAe,MAAMC,QAAQ,KAAM,KAFhDF,EAAUjC,KCFdjE,eAAeqG,iBAAiB5B,GACrC,OAAO9C,cAAcI,YAAUoC,KAAMM,GCDhCzE,eAAesG,eAAe7B,GACnC,OAAO9C,cAAcI,YAAUC,KAAMyC,GCDhCzE,eAAeuG,cAAc9B,GAClC,OAAO9C,cAAcI,YAAUsC,KAAMI,GCDhCzE,eAAewG,eAAe/B,GACnC,OAAO9C,cAAcI,YAAUwC,KAAME,GCFhCzE,eAAeyG,aAAahC,EAAYjB,EAAS,GACtD,IAEE,aADMkD,WAASjC,EAAYjB,IACpB,EACP,MAAOlD,GACP,OAAOA,GCNJ,SAASqG,SAASC,KAAUC,GACjC,IAAIC,EASJ,OAPEA,EADEC,MAAMC,QAAQJ,GACPA,EAAMK,IAAKzG,GAASA,EAAKoF,YAEzB,CAACgB,EAAMhB,YAEdiB,EAAUrD,SACZsD,EAASA,EAAOI,OAAOL,EAAUI,IAAKzG,GAASA,EAAKoF,cAE/CuB,YAAUhF,UAAQ2E,ICRpB9G,eAAeoH,gBAAgBtF,GACpC,MAAMY,QAAiBF,aAAaV,GACpC,IAAKiF,MAAMC,QAAQtE,GACjB,OAAOA,EAeT,aAb0B2E,QAAQC,IAChC5E,EAASuE,IAAIjH,MAAAA,IACX,MAAMuH,EAAcZ,SAAS7E,EAAW4B,IACjCxC,EAAQZ,SAAeC,UAAUgH,GACxC,IAAIjH,GAGCY,EAAOO,cAGZ,OAAOiC,MAGQf,OAAQe,GAAYA,GClBlC1D,eAAewH,UAAU1F,GAC9B,MAAMY,QAAiBF,aAAaV,GACpC,IAAKiF,MAAMC,QAAQtE,GACjB,OAAOA,EAeT,aAboB2E,QAAQC,IAC1B5E,EAASuE,IAAIjH,MAAAA,IACX,MAAMuH,EAAcZ,SAAS7E,EAAW4B,IACjCxC,EAAQZ,SAAeC,UAAUgH,GACxC,IAAIjH,IAGAY,EAAOO,cAGX,OAAOiC,MAGEf,OAAQe,GAAYA,GCpB5B1D,eAAeyH,KAAKd,EAAUe,GACnC,IAEE,aADMC,SAAOhB,EAAUe,IAChB,EACP,MAAOpH,GACP,OAAOA,GCbX,MAAMsH,EAAiBC,EAAGC,UAOnB,SAASC,aAAaC,GAC3B,OAAIJ,EACKK,OAAOD,GAAe5B,QAAQ,gBAAiBwB,GAEjDK,OAAOD,GCAT,SAASE,iBAAiBtB,KAAUC,GACzC,IAAIC,EASJ,OAPEA,EADEC,MAAMC,QAAQJ,GACPA,EAAMK,IAAKzG,GAASA,EAAKoF,YAEzB,CAACgB,EAAMhB,YAEdiB,EAAUrD,SACZsD,EAASA,EAAOI,OAAOL,EAAUI,IAAKzG,GAASA,EAAKoF,cAE/CmC,aAAaI,aAAWrB,ICd1B,SAASsB,cAAc5H,GAC5B,OAAO6H,UAAQ7H,GAAM8H,UAAU,GCD1B,SAASjG,SAAS7B,GACvB,OAAO+H,QAAM/H,GAAMgI,KCDd,SAASC,YAAYjI,GAC1B,OAAOkI,WAASlI,GCDX,SAASI,SAASJ,GACvB,OAAOY,UAAQZ,GCAVR,eAAe2I,iBAAiB1H,GACrC,IAEE,aADqB+D,WAAS/D,EAAU,WAC1B2E,WACd,MAAOtF,GACP,OAAOA,GCLJN,eAAe4I,iBAAiB3H,GACrC,IACE,MAAM4H,QAAe7D,WAAS/D,EAAU,UACxC,OAAO6H,OAAOC,KAAKF,GACnB,MAAOvI,GACP,OAAOA,GCHJN,eAAegJ,iBAAiB/H,GACrC,IAEE,aADqB+D,WAAS+C,aAAa9G,GAAW,SACxC2E,WACd,MAAOtF,GACP,OAAOA,GCbX,MAAM2I,EAAkC,UAArBC,QAAQC,SAkB3B,SAASC,OAAOnI,EAAUH,EAASuI,GACjC,IAAIC,EAAY,EACZC,EAAgBF,EAChBG,EAAe1I,EACS,mBAAjB0I,IACTD,EAAgBC,EAChBA,EAAe,IAEjBC,EAAOxI,EAAU,0BACjBwI,EAAOC,mBAAmBzI,EAAU,SAAU,qCAC9CwI,EAAOC,mBAAmBH,EAAe,WAAY,wCACrDE,EAAOD,EAAc,+CACrBC,EAAOC,mBAAmBF,EAAc,SAAU,sCAzBpD,SAASG,SAAS7I,GACA,CAAC,SAAU,QAAS,OAAQ,QAAS,QAAS,WACtD8C,QAASgG,IACf9I,EAAQ8I,GAAU9I,EAAQ8I,IAAWC,EAAGD,KAE1C9I,EAAQgJ,aAAehJ,EAAQgJ,cAAgB,EAqB/CH,CAASH,GACTO,QAAQ9I,EAAUuI,GAAc,SAASQ,eAAe1J,GACtD,GAAIA,EAAO,CACT,IACkB,UAAfA,EAAMe,MAAmC,cAAff,EAAMe,MAAuC,UAAff,EAAMe,OAC/DiI,EAAYE,EAAaM,aACzB,CACAR,IAGA,YADAW,WAAW,IAAMF,QAAQ9I,EAAUuI,EAAcQ,gBADxB,IAAZV,GAIf,GAAmB,WAAfhJ,EAAMe,KAER,YADAkI,EAAc,MAIlBA,EAAcjJ,MASlB,SAASyJ,QAAQ9I,EAAUH,EAASuI,GAClCI,EAAOxI,GACPwI,EAAO3I,GACP2I,EAA2B,mBAAbJ,GACdvI,EAAQoJ,MAAMjJ,EAAU,CAACX,EAAO6J,IAC1B7J,GAAwB,WAAfA,EAAMe,KACVgI,EAAS,MAEd/I,GAAwB,UAAfA,EAAMe,MAAoB4H,EAC9BmB,YAAYnJ,EAAUH,EAASR,EAAO+I,GAE3Cc,GAASA,EAAM1I,cACV4I,MAAMpJ,EAAUH,EAASR,EAAO+I,QAEzCvI,EAAQwJ,OAAOrJ,EAAWX,IACxB,GAAIA,EAAO,CACT,GAAmB,WAAfA,EAAMe,KACR,OAAOgI,EAAS,MAElB,GAAmB,UAAf/I,EAAMe,KACR,OAAI4H,EACKmB,YAAYnJ,EAAUH,EAASR,EAAO+I,GAEtCgB,MAAMpJ,EAAUH,EAASR,EAAO+I,GAG3C,GAAmB,WAAf/I,EAAMe,KACR,OAAOgJ,MAAMpJ,EAAUH,EAASR,EAAO+I,GAG3C,OAAOA,EAAS/I,MAYtB,SAAS8J,YAAYnJ,EAAUH,EAASR,EAAO+I,GA8B7C,OA7BAI,EAAOxI,GACPwI,EAAO3I,GACP2I,EAA2B,mBAAbJ,GACV/I,GACFmJ,EAAOnJ,aAAiB0C,OAE1BlC,EAAQyJ,MAAMtJ,EAAU,IAAQuJ,IAC1BA,EACsB,WAApBA,EAAWnJ,KACbgI,EAAS,MAETA,EAAS/I,GAGXQ,EAAQL,KAAKQ,EAAU,CAACwJ,EAAWN,KAC7BM,EACqB,WAAnBA,EAAUpJ,KACZgI,EAAS,MAETA,EAAS/I,GAEF6J,EAAM1I,cACf4I,MAAMpJ,EAAUH,EAASR,EAAO+I,GAEhCvI,EAAQwJ,OAAOrJ,EAAUoI,OAK1B,KAUT,SAASgB,MAAMpJ,EAAUH,EAAS4J,EAAerB,GAgB/C,OAfAI,EAAOxI,GACPwI,EAAO3I,GACH4J,GACFjB,EAAOiB,aAAyB1H,OAElCyG,EAA2B,mBAAbJ,GACdvI,EAAQuJ,MAAMpJ,EAAWX,KACnBA,GAAyB,cAAfA,EAAMe,MAAuC,WAAff,EAAMe,MAAoC,UAAff,EAAMe,KAElEf,GAAwB,YAAfA,EAAMe,KACxBgI,EAASqB,GAETrB,EAAS/I,GAWf,SAASqK,cAAc1J,EAAUH,EAASuI,GACxCI,EAAOxI,GACPwI,EAAO3I,GACP2I,EAA2B,mBAAbJ,GACdvI,EAAQY,QAAQT,EAAU,CAACX,EAAOsK,KAChC,GAAItK,EACF,OAAO+I,EAAS/I,GAElB,IACIuK,EADAC,EAAQF,EAAMpH,OAElB,GAAc,IAAVsH,EACF,OAAOhK,EAAQuJ,MAAMpJ,EAAUoI,GAEjCuB,EAAMhH,QAAShD,IACbwI,OAAOjH,OAAKlB,EAAUL,GAAWE,EAAUR,IACrCuK,IAGAvK,EACF+I,EAAUwB,EAAWvK,MAGrBwK,EACY,IAAVA,GACFhK,EAAQuJ,MAAMpJ,EAAUoI,WAvC5BsB,CAAc1J,EAAUH,EAASuI,KAO9B,KA+CFrJ,eAAe+K,OAAO9J,GAC3B,OAAO,IAAIoG,QAASc,IAClBiB,OAAOnI,EAAU,GAAKX,IAChBA,EACF6H,EAAQ7H,GAER6H,QC3MD,SAAS6C,kBAAkB/J,GAChC8J,OAAO9J,GACJgK,KAAK,QACLC,MAAM,QCAJlL,eAAemL,aAAalK,EAAUH,GAC3C,UACQsK,KAAGnK,EAAU,CACjBoK,OAAO,EACPjL,WAAW,KACRU,IAEL,MAAOwK,KCRJtL,eAAeuL,cAAc/K,GAClC,IACE,MAAO,OAAO0J,QAAM1J,IACpB,MAAOF,GACP,MAAO,MAACI,EAAWJ,ICLhBN,eAAewL,YAAYhL,GAChC,MAAOU,EAAQZ,SAAeC,UAAUC,GACxC,OAAIF,GAGGY,EAAOO,cCLTzB,eAAeyL,aAAajL,GACjC,MAAOU,EAAQZ,SAAeC,UAAUC,GACxC,OAAIF,GAGGY,EAAOC,SCLTnB,eAAe0L,aAAalL,GACjC,MAAOU,SAAgBX,UAAUC,GACjC,OAAOmL,QAAQzK,GCGVlB,eAAe4L,cAAchL,EAAUC,EAAMC,GAElD,IAAoB,UADM2K,aAAa7K,GACZ,CACzB,MAAMiL,QAA6B7K,WAAWJ,GAC9C,IAA6B,IAAzBiL,EACF,OAAOA,EAGX,MAAMC,QAAuB9C,iBAAiBpI,GAC9C,OAAIkL,aAA0B9I,MACrB8I,EAEF,IAAIzE,QAAQ,CAACc,EAAS4D,KAC3B9B,WAAW,KACTtJ,UAAUC,EAAW,GAAEqH,OAAO6D,KAAkB7D,OAAOpH,KAASC,GAC7DmK,KAAK,KACJ9C,GAAQ,KAET+C,MAAO5K,IACNyL,EAAOzL,MAEV,KCpBP,SAAS0L,aAAaC,GACpB,OAAiB,OAAVA,GAAmC,iBAAVA,IAAuBlF,MAAMC,QAAQiF,GASvE,SAASC,mBAAmBD,EAAOE,GAAS,GAC1C,IAAKH,aAAaC,GAChB,OAAIlF,MAAMC,QAAQiF,GACTA,EAAMhF,IAAKmF,GAAeF,mBAAmBE,EAAYD,IAE3DF,EAET,MAAMI,EA1BR,SAASC,WAAWC,GAClB,OAAOC,OAAOH,KAAKE,GAAQE,KAAK,CAACC,EAAOC,IAASD,EAAME,cAAcD,IAyBxDL,CAAWL,GACxB,OAAKI,EAAK7I,OAGH6I,EAAKQ,OAAO,CAACC,EAAQC,KACtBZ,GAAUH,aAAaC,EAAMc,KAEtBZ,GAAUpF,MAAMC,QAAQiF,EAAMc,IADvCD,EAAOC,GAAOb,mBAAmBD,EAAMc,GAAMZ,GAI7CW,EAAOC,GAAOd,EAAMc,GAEfD,GACN,IAXMb,EAyBJjM,eAAegN,UAAUpM,EAAUC,EAAMC,EAASmM,GACvD,IAAIC,EACAC,EAAYtM,EAChB,IACMoM,GACEA,EAAcR,OAEdU,EADEnB,aAAanL,GACHqL,mBAAmBkB,KAAK7E,MAAM6E,KAAKD,UAAUtM,KAChDkG,MAAMC,QAAQnG,GACXuM,KAAK7E,MAAM6E,KAAKD,UAAUtM,IAE1BA,GAGZoM,EAAcI,QAChBH,EAAOE,KAAKD,UAAUA,EAAW,KAAMF,EAAcI,SAGvDH,EAAOE,KAAKD,UAAUA,GAExB,MAAO7M,GACP,OAAOA,EAET,OAAOK,UAAUC,EAAUsM,EAAMpM,6gBC3B5B,MAAMwM,gBAAgBC,cAAAC,wCAWRtF,kBAAgBsF,uCAYjBvN,iBAAeuN,kCAWpBxM,YAAUwM,uCAULtJ,iBAAesJ,qCAUjB3L,eAAa2L,oCAUdpJ,cAAYoJ,qCAUXlJ,eAAakJ,kCAYhB3K,YAAU2K,qCAUPjC,eAAaiC,iCAUjBjN,WAASiN,mCAUPhC,aAAWgC,oCAUV/B,cAAY+B,oCAUZ9B,cAAY8B,qCASXpF,eAAaoF,gCASlBnL,UAAQmL,mCASL/E,aAAW+E,gCASd5M,UAAQ4M,wCAUAnH,kBAAgBmH,sCAUlBlH,gBAAckH,qCAUfjH,eAAaiH,sCAUZhH,gBAAcgH,oCAWhB/G,cAAY+G,4BAYpBhJ,MAAIgJ,iCAUCtI,WAASsI,+BAUX3H,SAAO2H,gCAUN1H,UAAQ0H,kCAUNzH,YAAUyH,kCAUVxH,YAAUwH,oCASRhL,cAAYgL,uCASTpG,iBAAeoG,iCASrBhG,WAASgG,4BAUd/F,MAAI+F,gCAUA7G,UAAQ6G,wCASA7E,kBAAgB6E,wCAShB5E,kBAAgB4E,wCAShBxE,kBAAgBwE,8BAU1BzC,QAAMyC,yCASKxC,mBAAiBwC,oCAWtBrC,cAAYqC,4BAWpBvJ,MAAIuJ,iCAYC7M,WAAS6M,qCAYL5B,eAAa4B,iCAYjBR"}