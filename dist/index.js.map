{"version":3,"file":"index.js","sources":["../src/core/create/createDirectory.mjs","../src/core/status/getStatus.mjs","../src/core/write/writeFile.mjs","../src/core/create/createFile.mjs","../src/core/access/wrapper.mjs","../src/core/dir/dirIsExecutable.mjs","../src/core/dir/dirIsReadable.mjs","../src/core/dir/dirIsVisible.mjs","../src/core/dir/dirIsWritable.mjs","../src/core/file/fileIsExecutable.mjs","../src/core/file/fileIsReadable.mjs","../src/core/file/fileIsVisible.mjs","../src/core/file/fileIsWritable.mjs","../src/core/file/fileTruncate.mjs","../src/core/status/isDirExists.mjs","../src/core/status/isFileExists.mjs","../src/core/status/isPathExists.mjs","../src/core/HileSystemLocal.mjs"],"sourcesContent":["import { promises } from \"fs\";\n\nimport { ofError } from \"@r37r0m0d3l/of\";\n\n/**\n * @name createDirectory\n * @description Asynchronous create a directory.\n * @since 0.0.10\n * @async\n * @param {string|Buffer|URL} dirPath\n * @param {number|string=} mode\n * @param {boolean=} recursive\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function createDirectory(dirPath, mode = \"0777\", recursive = true) {\n  const dirError = await ofError(promises.mkdir(dirPath, { mode, recursive }));\n  if (dirError) {\n    return dirError;\n  }\n  return true;\n}\n","import { promises } from \"fs\";\n\nimport { of } from \"@r37r0m0d3l/of\";\n\n/**\n * @name getStatus\n * @description Get file status.\n * @since 0.0.11\n * @async\n * @param {string|Buffer|URL} path\n * @returns {Promise<[fs.Stats|undefined],[Error|{name: string, message: string, stack?: string}]>}\n */\nexport async function getStatus(path) {\n  return of(promises.stat(path));\n}\n","import { promises } from \"fs\";\n\nimport { ofError } from \"@r37r0m0d3l/of\";\n\n/**\n * @name writeFile\n * @description Asynchronously writes data to a file, replacing the file if it already exists.\n * @since 0.0.10\n * @async\n * @param {string|Buffer|URL|FileHandle} filePath\n * @param {*=} data\n * @param {*|null|string=} options\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function writeFile(filePath, data, options) {\n  const writeError = await ofError(promises.writeFile(filePath, data, options));\n  if (writeError) {\n    return writeError;\n  }\n  return true;\n}\n","import path from \"path\";\nimport { promises } from \"fs\";\n\nimport { ofError } from \"@r37r0m0d3l/of\";\n\nimport { createDirectory } from \"./createDirectory\";\nimport { getStatus } from \"../status/getStatus\";\nimport { writeFile } from \"../write/writeFile\";\n\n/**\n * @name createFile\n * @description Asynchronous create a file.\n * @since 0.0.11\n * @async\n * @param {string|Buffer|URL} pathLike\n * @param {number|string=} mode\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function createFile(pathLike, mode = \"0777\") {\n  const [status, error] = await getStatus(pathLike);\n  if (!error && status.isFile()) {\n    return true;\n  }\n  const dirPath = path.dirname(pathLike);\n  if (error) {\n    if (error.code === \"ENOENT\") {\n      const dirCreated = await createDirectory(dirPath, mode);\n      if (dirCreated !== true) {\n        return dirCreated;\n      }\n      const fileWritten = await writeFile(pathLike, \"\", { mode, flag: \"w\" });\n      if (fileWritten !== true) {\n        return fileWritten;\n      }\n      return true;\n    }\n  }\n  if (status.isDirectory()) {\n    return await writeFile(pathLike, \"\", { mode, flag: \"w\" });\n  } else {\n    return await ofError(promises.readdir(dirPath));\n  }\n}\n","import * as fs from \"fs\";\n\nimport { ofError } from \"@r37r0m0d3l/of\";\n\n/**\n * @name accessWrapper\n * @description Asynchronously tests a user's permissions for the file specified by path.\n * @since 0.0.1\n * @async\n * @param {number} mode\n * @param {string|Buffer|URL} path\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function accessWrapper(mode, path) {\n  const fsError = await ofError(fs.promises.access(path, mode));\n  if (!fsError) {\n    return true;\n  }\n  return fsError;\n}\n","import { constants } from \"fs\";\n\nimport { accessWrapper } from \"../access/wrapper\";\n\n/**\n * @name dirIsExecutable\n * @description Directory can be executed by the calling process\n * @since 0.0.5\n * @async\n * @param {string|Buffer|URL} pathToDir\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function dirIsExecutable(pathToDir) {\n  return accessWrapper(constants.X_OK, pathToDir);\n}\n","import { constants } from \"fs\";\n\nimport { accessWrapper } from \"../access/wrapper\";\n\n/**\n * @name dirIsReadable\n * @description Directory is visible to the calling process\n * @since 0.0.1\n * @async\n * @param {string|Buffer|URL} pathToDir\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function dirIsReadable(pathToDir) {\n  return accessWrapper(constants.R_OK, pathToDir);\n}\n","import { constants } from \"fs\";\n\nimport { accessWrapper } from \"../access/wrapper\";\n\n/**\n * @name dirIsVisible\n * @description Directory is visible to the calling process\n * @since 0.0.5\n * @async\n * @param {string|Buffer|URL} pathToDir\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function dirIsVisible(pathToDir) {\n  return accessWrapper(constants.F_OK, pathToDir);\n}\n","import { constants } from \"fs\";\n\nimport { accessWrapper } from \"../access/wrapper\";\n\n/**\n * @name dirIsWritable\n * @description Directory can be written by the calling process\n * @since 0.0.1\n * @async\n * @param {string|Buffer|URL} pathToDir\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function dirIsWritable(pathToDir) {\n  return accessWrapper(constants.W_OK, pathToDir);\n}\n","import { constants } from \"fs\";\n\nimport { accessWrapper } from \"../access/wrapper\";\n\n/**\n * @name fileIsExecutable\n * @description File can be executed by the calling process\n * @since 0.0.5\n * @async\n * @param {string|Buffer|URL} pathToFile\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function fileIsExecutable(pathToFile) {\n  return accessWrapper(constants.X_OK, pathToFile);\n}\n","import { constants } from \"fs\";\n\nimport { accessWrapper } from \"../access/wrapper\";\n\n/**\n * @name fileIsReadable\n * @description File is visible to the calling process\n * @since 0.0.1\n * @async\n * @param {string|Buffer|URL} pathToFile\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function fileIsReadable(pathToFile) {\n  return accessWrapper(constants.R_OK, pathToFile);\n}\n","import { constants } from \"fs\";\n\nimport { accessWrapper } from \"../access/wrapper\";\n\n/**\n * @name fileIsVisible\n * @description File is visible to the calling process\n * @since 0.0.5\n * @async\n * @param {string|Buffer|URL} pathToFile\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function fileIsVisible(pathToFile) {\n  return accessWrapper(constants.F_OK, pathToFile);\n}\n","import { constants } from \"fs\";\n\nimport { accessWrapper } from \"../access/wrapper\";\n\n/**\n * @name fileIsWritable\n * @description File can be written by the calling process\n * @since 0.0.1\n * @async\n * @param {string|Buffer|URL} pathToFile\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function fileIsWritable(pathToFile) {\n  return accessWrapper(constants.W_OK, pathToFile);\n}\n","import { promises } from \"fs\";\n\nimport { ofError } from \"@r37r0m0d3l/of\";\n\n/**\n * @name fileTruncate\n * @description Truncate a file to a specified length\n * @since 0.0.6\n * @async\n * @param {string|Buffer|URL} pathToFile\n * @param {number=} length\n * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n */\nexport async function fileTruncate(pathToFile, length = 0) {\n  const fsError = await ofError(promises.truncate(pathToFile, length));\n  if (!fsError) {\n    return true;\n  }\n  return fsError;\n}\n","import { getStatus } from \"./getStatus\";\n\n/**\n * @name isDirExists\n * @description Get directory status.\n * @since 0.0.11\n * @async\n * @param {string|Buffer|URL} path\n * @returns {Promise<boolean>}\n */\nexport async function isDirExists(path) {\n  const [status, error] = await getStatus(path);\n  if (error) {\n    return false;\n  }\n  return status.isDirectory();\n}\n","import { getStatus } from \"./getStatus\";\n\n/**\n * @name isFileExists\n * @description Get file status.\n * @since 0.0.11\n * @async\n * @param {string|Buffer|URL} path\n * @returns {Promise<boolean>}\n */\nexport async function isFileExists(path) {\n  const [status, error] = await getStatus(path);\n  if (error) {\n    return false;\n  }\n  return status.isFile();\n}\n","import { getStatus } from \"./getStatus\";\n\n/**\n * @name isPathExists\n * @description Get path status.\n * @since 0.0.11\n * @async\n * @param {string|Buffer|URL} path\n * @returns {Promise<boolean>}\n */\nexport async function isPathExists(path) {\n  const [status] = await getStatus(path);\n  return Boolean(status);\n}\n","import { createDirectory } from \"./create/createDirectory\";\nimport { createFile } from \"./create/createFile\";\nimport { dirIsExecutable } from \"./dir/dirIsExecutable\";\nimport { dirIsReadable } from \"./dir/dirIsReadable\";\nimport { dirIsVisible } from \"./dir/dirIsVisible\";\nimport { dirIsWritable } from \"./dir/dirIsWritable\";\nimport { fileIsExecutable } from \"./file/fileIsExecutable\";\nimport { fileIsReadable } from \"./file/fileIsReadable\";\nimport { fileIsVisible } from \"./file/fileIsVisible\";\nimport { fileIsWritable } from \"./file/fileIsWritable\";\nimport { fileTruncate } from \"./file/fileTruncate\";\nimport { getStatus } from \"./status/getStatus\";\nimport { isDirExists } from \"./status/isDirExists\";\nimport { isFileExists } from \"./status/isFileExists\";\nimport { isPathExists } from \"./status/isPathExists\";\nimport { writeFile } from \"./write/writeFile\";\n\nexport class HileSystemLocal {\n  /**\n   * @name createDirectory\n   * @description Asynchronous create a directory.\n   * @since 0.0.10\n   * @async\n   * @public\n   * @param {string|Buffer|URL} dirPath\n   * @param {number|string=} mode\n   * @param {boolean=} recursive\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  createDirectory = createDirectory;\n  /**\n   * @name createFile\n   * @description Asynchronous create a file.\n   * @since 0.0.11\n   * @async\n   * @public\n   * @param {string|Buffer|URL} pathLike\n   * @param {number|string=} mode\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  createFile = createFile;\n  /**\n   * @name dirIsExecutable\n   * @description Directory can be executed by the calling process\n   * @since 0.0.5\n   * @async\n   * @public\n   * @param {string} pathToDir\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  dirIsExecutable = dirIsExecutable;\n  /**\n   * @name dirIsReadable\n   * @description Directory is visible to the calling process\n   * @since 0.0.1\n   * @async\n   * @public\n   * @param {string} pathToDir\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  dirIsReadable = dirIsReadable;\n  /**\n   * @name dirIsVisible\n   * @description Directory is visible to the calling process\n   * @since 0.0.5\n   * @async\n   * @public\n   * @param {string} pathToDir\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  dirIsVisible = dirIsVisible;\n  /**\n   * @name dirIsWritable\n   * @description Directory can be written by the calling process\n   * @since 0.0.1\n   * @async\n   * @public\n   * @param {string} pathToDir\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  dirIsWritable = dirIsWritable;\n  /**\n   * @name getStatus\n   * @description Get file status.\n   * @since 0.0.11\n   * @async\n   * @public\n   * @param {string|Buffer|URL} path\n   * @returns {Promise<[fs.Stats|undefined],[Error|{name: string, message: string, stack?: string}]>}\n   */\n  getStatus = getStatus;\n  /**\n   * @name isDirExists\n   * @description Get directory status.\n   * @since 0.0.11\n   * @async\n   * @public\n   * @param {string|Buffer|URL} path\n   * @returns {Promise<boolean>}\n   */\n  isDirExists = isDirExists;\n  /**\n   * @name isFileExists\n   * @description Get file status.\n   * @since 0.0.11\n   * @async\n   * @public\n   * @param {string|Buffer|URL} path\n   * @returns {Promise<boolean>}\n   */\n  isFileExists = isFileExists;\n  /**\n   * @name isPathExists\n   * @description Get path status.\n   * @since 0.0.11\n   * @async\n   * @public\n   * @param {string|Buffer|URL} path\n   * @returns {Promise<boolean>}\n   */\n  isPathExists = isPathExists;\n  /**\n   * @name fileIsExecutable\n   * @description File can be executed by the calling process\n   * @since 0.0.5\n   * @async\n   * @public\n   * @param {string|Buffer|URL} pathToFile\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  fileIsExecutable = fileIsExecutable;\n  /**\n   * @name fileIsReadable\n   * @description File is visible to the calling process\n   * @since 0.0.1\n   * @async\n   * @public\n   * @param {string|Buffer|URL} pathToFile\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  fileIsReadable = fileIsReadable;\n  /**\n   * @name fileIsVisible\n   * @description File is visible to the calling process\n   * @since 0.0.5\n   * @async\n   * @public\n   * @param {string|Buffer|URL} pathToFile\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  fileIsVisible = fileIsVisible;\n  /**\n   * @name fileIsWritable\n   * @description File can be written by the calling process\n   * @since 0.0.1\n   * @async\n   * @public\n   * @param {string|Buffer|URL} pathToFile\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  fileIsWritable = fileIsWritable;\n  /**\n   * @name fileTruncate\n   * @description Truncate a file to a specified length\n   * @since 0.0.6\n   * @async\n   * @public\n   * @param {string|Buffer|URL} pathToFile\n   * @param {number=} length\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  fileTruncate = fileTruncate;\n  /**\n   * @name writeFile\n   * @description Asynchronously writes data to a file, replacing the file if it already exists.\n   * @since 0.0.10\n   * @async\n   * @public\n   * @param {string|Buffer|URL|FileHandle} filePath\n   * @param {*=} data\n   * @param {*|null|string=} options\n   * @returns {Promise<boolean|Error|{name: string, message: string, stack?: string}>}\n   */\n  writeFile = writeFile;\n}\n"],"names":["async","createDirectory","dirPath","mode","recursive","dirError","ofError","promises","mkdir","getStatus","path","of","stat","writeFile","filePath","data","options","writeError","createFile","pathLike","status","error","isFile","dirname","code","dirCreated","fileWritten","flag","isDirectory","readdir","accessWrapper","fsError","fs","access","dirIsExecutable","pathToDir","constants","X_OK","dirIsReadable","R_OK","dirIsVisible","F_OK","dirIsWritable","W_OK","fileIsExecutable","pathToFile","fileIsReadable","fileIsVisible","fileIsWritable","fileTruncate","length","truncate","isDirExists","isFileExists","isPathExists","Boolean","HileSystemLocal"],"mappings":"qbAcOA,eAAeC,gBAAgBC,EAASC,EAAO,OAAQC,GAAY,SAClEC,QAAiBC,UAAQC,WAASC,MAAMN,EAAS,CAAEC,KAAAA,EAAMC,UAAAA,YAC3DC,IAGG,ECPFL,eAAeS,UAAUC,UACvBC,KAAGJ,WAASK,KAAKF,ICCnBV,eAAea,UAAUC,EAAUC,EAAMC,SACxCC,QAAmBX,UAAQC,WAASM,UAAUC,EAAUC,EAAMC,WAChEC,IAGG,ECDFjB,eAAekB,WAAWC,EAAUhB,EAAO,cACzCiB,EAAQC,SAAeZ,UAAUU,OACnCE,GAASD,EAAOE,gBACZ,QAEHpB,EAAUQ,EAAKa,QAAQJ,MACzBE,GACiB,WAAfA,EAAMG,KAAmB,OACrBC,QAAmBxB,gBAAgBC,EAASC,OAC/B,IAAfsB,SACKA,QAEHC,QAAoBb,UAAUM,EAAU,GAAI,CAAEhB,KAAAA,EAAMwB,KAAM,aAC5C,IAAhBD,GACKA,SAKTN,EAAOQ,oBACIf,UAAUM,EAAU,GAAI,CAAEhB,KAAAA,EAAMwB,KAAM,YAEtCrB,UAAQC,WAASsB,QAAQ3B,IC3BnCF,eAAe8B,cAAc3B,EAAMO,SAClCqB,QAAgBzB,UAAQ0B,WAAYC,OAAOvB,EAAMP,WAClD4B,IACI,ECJJ/B,eAAekC,gBAAgBC,UAC7BL,cAAcM,YAAUC,KAAMF,GCDhCnC,eAAesC,cAAcH,UAC3BL,cAAcM,YAAUG,KAAMJ,GCDhCnC,eAAewC,aAAaL,UAC1BL,cAAcM,YAAUK,KAAMN,GCDhCnC,eAAe0C,cAAcP,UAC3BL,cAAcM,YAAUO,KAAMR,GCDhCnC,eAAe4C,iBAAiBC,UAC9Bf,cAAcM,YAAUC,KAAMQ,GCDhC7C,eAAe8C,eAAeD,UAC5Bf,cAAcM,YAAUG,KAAMM,GCDhC7C,eAAe+C,cAAcF,UAC3Bf,cAAcM,YAAUK,KAAMI,GCDhC7C,eAAegD,eAAeH,UAC5Bf,cAAcM,YAAUO,KAAME,GCAhC7C,eAAeiD,aAAaJ,EAAYK,EAAS,SAChDnB,QAAgBzB,UAAQC,WAAS4C,SAASN,EAAYK,WACvDnB,IACI,ECNJ/B,eAAeoD,YAAY1C,SACzBU,EAAQC,SAAeZ,UAAUC,UACpCW,GAGGD,EAAOQ,cCLT5B,eAAeqD,aAAa3C,SAC1BU,EAAQC,SAAeZ,UAAUC,UACpCW,GAGGD,EAAOE,SCLTtB,eAAesD,aAAa5C,SAC1BU,SAAgBX,UAAUC,UAC1B6C,QAAQnC,wFCKV,MAAMoC,qEAYOvD,mDAWLiB,mDAUKgB,sDAUFI,mDAUDE,mDAUCE,gDAUJjC,8CAUE2C,iDAUCC,kDAUAC,sDAUIV,wDAUFE,qDAUDC,qDAUCC,oDAWFC,+CAYHpC"}